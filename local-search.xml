<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode 8 字符串转换整数 (atoi)</title>
    <link href="/2024/02/07/LeetCode_8/"/>
    <url>/2024/02/07/LeetCode_8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="1 问题描述[1]"></a><span class="label label-primary">1 问题描述<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[LeetCode 8. 字符串转换整数 (atoi)](https://leetcode.cn/problems/string-to-integer-atoi/)">[1]</span></a></sup></span></h2><p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C&#x2F;C++ 中的 atoi 函数）。</p><p>函数 myAtoi(string s) 的算法如下：</p><p>读入字符串并丢弃无用的前导空格<br>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。<br>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。<br>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。<br>如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。<br>返回整数作为最终结果。<br>注意：</p><p>本题中的空白字符只包括空格字符 ‘ ‘ 。<br>除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。</p><p>示例 1：</p><p>输入：s &#x3D; “42”<br>输出：42<br>解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。<br>第 1 步：”42”（当前没有读入字符，因为没有前导空格）<br>         ^<br>第 2 步：”42”（当前没有读入字符，因为这里不存在 ‘-‘ 或者 ‘+’）<br>         ^<br>第 3 步：”42”（读入 “42”）<br>           ^<br>解析得到整数 42 。<br>由于 “42” 在范围 [-231, 231 - 1] 内，最终结果为 42 。<br>示例 2：</p><p>输入：s &#x3D; “   -42”<br>输出：-42<br>解释：<br>第 1 步：”   -42”（读入前导空格，但忽视掉）<br>            ^<br>第 2 步：”   -42”（读入 ‘-‘ 字符，所以结果应该是负数）<br>             ^<br>第 3 步：”   -42”（读入 “42”）<br>               ^<br>解析得到整数 -42 。<br>由于 “-42” 在范围 [-231, 231 - 1] 内，最终结果为 -42 。<br>示例 3：</p><p>输入：s &#x3D; “4193 with words”<br>输出：4193<br>解释：<br>第 1 步：”4193 with words”（当前没有读入字符，因为没有前导空格）<br>         ^<br>第 2 步：”4193 with words”（当前没有读入字符，因为这里不存在 ‘-‘ 或者 ‘+’）<br>         ^<br>第 3 步：”4193 with words”（读入 “4193”；由于下一个字符不是一个数字，所以读入停止）<br>             ^<br>解析得到整数 4193 。<br>由于 “4193” 在范围 [-231, 231 - 1] 内，最终结果为 4193 。</p><p>提示：</p><p>0 &lt;&#x3D; s.length &lt;&#x3D; 200<br>s 由英文字母（大写和小写）、数字（0-9）、’ ‘、’+’、’-‘ 和 ‘.’ 组成</p><h2 id="2-Solution-Finite-State-Machine"><a href="#2-Solution-Finite-State-Machine" class="headerlink" title="2 Solution: Finite State Machine"></a><span class="label label-info">2 Solution: Finite State Machine</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">myAtoi</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        i, res, state, sign = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>        <br>        <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(s):<br>            <span class="hljs-keyword">if</span> state == <span class="hljs-number">0</span>:<br>                <span class="hljs-comment"># ignore leading white space</span><br>                <span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27; &#x27;</span>:<br>                    i += <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">&#x27;+&#x27;</span>:<br>                    i += <span class="hljs-number">1</span><br>                    state = <span class="hljs-number">1</span><br>                <span class="hljs-keyword">elif</span> s[i] == <span class="hljs-string">&#x27;-&#x27;</span>:<br>                    i += <span class="hljs-number">1</span><br>                    state = <span class="hljs-number">1</span><br>                    sign = -<span class="hljs-number">1</span><br>                <span class="hljs-comment"># s[i].isdigit()</span><br>                <span class="hljs-keyword">elif</span> s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>:<br>                    state = <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">return</span> res<br>            <span class="hljs-keyword">elif</span> state == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">if</span> s[i] &gt;= <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-keyword">and</span> s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>:<br>                    res = res * <span class="hljs-number">10</span> + <span class="hljs-built_in">ord</span>(s[i]) - <span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;0&#x27;</span>)<br>                    i += <span class="hljs-number">1</span><br>                    <br>                    <span class="hljs-comment"># 对于正数来说，已经越界；对于负数来说，虽然2**31没有越界，但是返回值同越界时相同</span><br>                    <span class="hljs-keyword">if</span> res &gt;= <span class="hljs-number">2</span>**<span class="hljs-number">31</span>:<br>                        <span class="hljs-keyword">break</span><br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-keyword">break</span><br><br>        res *= sign<br>        <span class="hljs-comment"># limit to the range of 32-bit integer values</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">min</span>(res, <span class="hljs-number">2</span>**<span class="hljs-number">31</span> -<span class="hljs-number">1</span>), -<span class="hljs-number">2</span>**<span class="hljs-number">31</span>)<br></code></pre></td></tr></table></figure><p>这段代码实现了将字符串转换为整数的功能，类似于 <code>int()</code> 函数的作用。主要是考虑了字符串可能包含的各种情况，包括正负号、空格等。以下是代码的解释：</p><ol><li><p><code>i, res, state, sign = 0, 0, 0, 1</code>: 初始化变量 <code>i</code>（索引）、<code>res</code>（结果）、<code>state</code>（状态）、<code>sign</code>（符号），开始时状态为0，符号为正。</p></li><li><p><code>while i &lt; len(s):</code>: 循环遍历字符串 <code>s</code>。</p></li><li><p>在 <code>state</code> 为0时，主要处理空格、正负号的情况，或者数字的开头。如果是空格，则继续往后移动；如果是正号或负号，则修改状态为1，并更新符号；如果是数字，则将状态改为1。</p></li><li><p>在 <code>state</code> 为1时，处理数字的情况。将数字字符转换为整数并加到结果 <code>res</code> 中，同时更新索引 <code>i</code>。检查是否越界，如果越界（超过32位整数的表示范围），则中断循环。</p></li><li><p>最后，乘以符号 <code>sign</code>，并限制结果在32位整数的范围内，即 <code>max(min(res, 2**31 -1), -2**31)</code>。</p></li></ol><p>总体来说，这段代码通过 <strong>状态机(state machine)</strong> 的方式逐个字符处理输入字符串，确保提取出符合要求的整数，并防止越界。</p><p class="note note-info">状态机（State Machine）是一种抽象的数学模型，用于描述对象在不同状态之间的转移以及在每个状态下对输入的响应。状态机通常用于建模和解决与状态相关的问题，如字符串匹配、编译器、自动控制系统等。</p><h2 id="3-引用"><a href="#3-引用" class="headerlink" title="3 引用"></a><span class="label label-warning">3 引用</span></h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://leetcode.cn/problems/string-to-integer-atoi/">LeetCode 8. 字符串转换整数 (atoi)</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Computational Model</category>
      
      <category>State Machine</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>State Machine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 5 最长回文子串</title>
    <link href="/2024/02/07/LeetCode_5/"/>
    <url>/2024/02/07/LeetCode_5/</url>
    
    <content type="html"><![CDATA[<h2 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="1 问题描述[1]"></a><span class="label label-primary">1 问题描述<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[LeetCode 5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)">[1]</span></a></sup></span></h2><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p>示例 1：</p><p>输入：s &#x3D; “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。<br>示例 2：</p><p>输入：s &#x3D; “cbbd”<br>输出：”bb”</p><p>提示：</p><p>1 &lt;&#x3D; s.length &lt;&#x3D; 1000<br>s 仅由数字和英文字母组成</p><h2 id="2-Solution-Expand-From-Center"><a href="#2-Solution-Expand-From-Center" class="headerlink" title="2 Solution: Expand From Center"></a><span class="label label-info">2 Solution: Expand From Center</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">expand_from_center</span>(<span class="hljs-params">left, right</span>):<br>            <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            从给定的左右索引向两侧扩展，找到最长回文串</span><br><span class="hljs-string">            &quot;&quot;&quot;</span><br>            <span class="hljs-keyword">while</span> left &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> right &lt; <span class="hljs-built_in">len</span>(s) <span class="hljs-keyword">and</span> s[left] == s[right]:<br>                left -= <span class="hljs-number">1</span><br>                right += <span class="hljs-number">1</span><br>            <br>            <span class="hljs-keyword">return</span> s[left + <span class="hljs-number">1</span>:right]<br><br>        longest = <span class="hljs-string">&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(s)):<br>            <span class="hljs-comment"># 以字符为中心expand</span><br>            palindrome1 = expand_from_center(i, i)<br>            <span class="hljs-comment"># 以空隙为中心expand</span><br>            palindrome2 = expand_from_center(i, i+<span class="hljs-number">1</span>)<br><br>            longest = <span class="hljs-built_in">max</span>([palindrome1, palindrome2, longest], key=<span class="hljs-built_in">len</span>)<br>            <br>        <span class="hljs-keyword">return</span> longest<br></code></pre></td></tr></table></figure><p>下面是对代码的基本原理解释：</p><ol><li><p><strong><code>expand_from_center</code> 函数：</strong></p><ul><li>这是一个辅助函数，用于以给定的左右索引向两侧扩展，找到最长回文串。</li><li>函数中的 <code>while</code> 循环检查当前的左右索引是否满足回文串的条件（字符相等），如果满足，则继续向两侧扩展。</li><li>返回找到的最长回文串。</li></ul></li><li><p><strong><code>longestPalindrome</code> 方法：</strong></p><ul><li>该方法使用了中心扩展法，遍历字符串中的每个字符，首先以当前字符为中心，向两侧扩展，计算出最长的回文串。然后以当前字符后面的间隙为中心计算最长的回文串。</li><li>在每次扩展中，通过 <code>expand_from_center</code> 函数找到当前情况下的最长回文串，并使用 <code>max</code> 函数比较当前回文串与历史最长回文串的长度，保留较长的那一个。</li></ul></li><li><p><strong>返回结果：</strong></p><ul><li>在遍历结束后，<code>longest</code> 中保存的就是整个字符串中最长的回文串。</li><li>最后将最长回文串返回。</li></ul></li></ol><p>这种算法的时间复杂度是 O(n^2)，其中 n 是字符串的长度。因为对于每个字符，最坏情况下需要扩展到字符串的两端，因此总体复杂度为 O(n^2)。</p><p>这段代码的空间复杂度主要取决于存储中间结果的空间。具体来说，空间复杂度包括了用于存储回文串的最长字符串 <code>longest</code> 的空间。</p><ol><li><p><strong><code>expand_from_center</code> 函数：</strong></p><ul><li>该函数的空间复杂度是 O(1)，因为它只使用了常数级别的额外空间，主要是用于存储循环中的局部变量。</li></ul></li><li><p><strong><code>longestPalindrome</code> 方法：</strong></p><ul><li>除了 <code>expand_from_center</code> 函数的常数级别的空间外，主要的空间开销在于用于存储最长回文串 <code>longest</code> 的字符串。在最坏情况下，<code>longest</code> 可能需要存储整个输入字符串，因此空间复杂度是 O(n)，其中 n 是输入字符串的长度。</li></ul></li></ol><p>综合考虑，整个代码的空间复杂度为 O(n)。</p><h2 id="3-Solution-Dynamic-Programming"><a href="#3-Solution-Dynamic-Programming" class="headerlink" title="3 Solution: Dynamic Programming"></a><span class="label label-success">3 Solution: Dynamic Programming</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">longestPalindrome</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-comment"># dp[i,j]为True表示 s[i, j+1]是一个回文串</span><br>        n = <span class="hljs-built_in">len</span>(s)<br>        dp = [[<span class="hljs-literal">False</span>] * n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        longest = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br><br>        <span class="hljs-comment"># 初始化 dp[i, i] = True，找到所有长度为1的回文串</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>            dp[i][i] = <span class="hljs-literal">True</span><br><br>        <span class="hljs-comment"># 找到所有长度为2的回文串</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> s[i] == s[i + <span class="hljs-number">1</span>]:<br>                dp[i][i + <span class="hljs-number">1</span>] = <span class="hljs-literal">True</span><br>                longest = [i, i + <span class="hljs-number">1</span>]<br><br>        <span class="hljs-comment"># 依次找到所有长度为3, 4, 5... n的回文串</span><br>        <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>, n + <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n - l + <span class="hljs-number">1</span>):<br>                j = i + l - <span class="hljs-number">1</span><br>                <span class="hljs-keyword">if</span> s[i] == s[j] <span class="hljs-keyword">and</span> dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]:<br>                    dp[i][j] = <span class="hljs-literal">True</span><br>                    longest = [i, j]<br><br>        <span class="hljs-keyword">return</span> s[longest[<span class="hljs-number">0</span>]:longest[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>下面是代码的主要原理：</p><ol><li><p><strong>动态规划矩阵 <code>dp</code>：</strong></p><ul><li>创建一个二维的动态规划矩阵 <code>dp</code>，其中 <code>dp[i][j]</code> 为 <code>True</code> 表示字符串 <code>s[i, j+1]</code> 是一个回文串。</li><li>初始化整个矩阵为 <code>False</code>。</li></ul></li><li><p><strong>基本情况处理：</strong></p><ul><li><p>对角线上的元素 <code>dp[i][i]</code> 初始化为 <code>True</code>，因为单个字符一定是回文串。下面以<code>&quot;cdabbacc&quot;</code>为例：</p>   <img src="dp1.png" style="width: 50%; height: 50%;"/></li><li><p>找到将所有长度为2的回文串并初始化为<code>True</code>。</p>   <img src="dp2.png" style="width: 50%; height: 50%;"/></li></ul></li><li><p><strong>依次处理长度为 3 及以上的回文串：</strong></p><ul><li><p>使用两层循环，外层循环 <code>l</code> 从 3 开始，表示当前考虑的回文串的长度。</p></li><li><p>内层循环 <code>i</code> 遍历字符串，<code>j</code> 根据当前长度 <code>l</code> 确定。</p></li><li><p>如果当前 <code>s[i] == s[j]</code> 且 <code>dp[i+1][j-1]</code> 为 <code>True</code>，则表示当前子串是回文串，更新 <code>dp[i][j]</code> 为 <code>True</code>。</p><p>例如计算<code>dp[0][2]</code>时，只需要查看<code>dp[1][1]</code>是不是回文串，若是且<code>s[0] == s[2]</code>，则<code>dp[0][2]</code>是回文串。</p></li><li><p>在每次更新回文串状态时，更新 <code>longest</code> 记录当前找到的最长回文串的起始和结束位置。</p></li><li><p>最终 <code>dp</code> 数组如下:</p>   <img src="dp3.png" style="width: 50%; height: 50%;"/></li></ul></li><li><p><strong>返回最长回文串：</strong></p><ul><li>最终返回 <code>s[longest[0]:longest[1] + 1]</code>，即找到的最长回文子串。</li></ul></li></ol><p>这种动态规划方法充分利用了子问题的解来构建整体问题的解，通过填充动态规划矩阵，最终找到了给定字符串中的最长回文子串。代码的时间复杂度是<code>O(n^2)</code>，空间复杂度也是<code>O(n^2)</code>。</p><h2 id="4-Solution-Manacher’s-Algorithm"><a href="#4-Solution-Manacher’s-Algorithm" class="headerlink" title="4 Solution: Manacher’s Algorithm"></a><span class="label label-danger">4 Solution: Manacher’s Algorithm</span></h2><p><strong>TODO</strong></p><p>Manacher’s algorithm<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Manacher's algorithm](https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm)">[2]</span></a></sup> finds the longest palindromic substring in <code>O(n)</code> time and space.</p><h2 id="5-引用"><a href="#5-引用" class="headerlink" title="5 引用"></a><span class="label label-warning">5 引用</span></h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://leetcode.cn/problems/longest-palindromic-substring/">LeetCode 5. 最长回文子串</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm">Manacher’s algorithm</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Dynamic Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>Dynamic Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 3 无重复字符的最长子串</title>
    <link href="/2024/02/07/LeetCode_3/"/>
    <url>/2024/02/07/LeetCode_3/</url>
    
    <content type="html"><![CDATA[<h2 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="1 问题描述[1]"></a><span class="label label-primary">1 问题描述<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[LeetCode 3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)">[1]</span></a></sup></span></h2><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><p><strong>示例 1:</strong></p><p>输入: s &#x3D; “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><p><strong>示例 2:</strong></p><p>输入: s &#x3D; “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p><p><strong>示例 3:</strong></p><p>输入: s &#x3D; “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><p><strong>提示：</strong></p><p>0 &lt;&#x3D; s.length &lt;&#x3D; 5 * 10^4<br>s 由英文字母、数字、符号和空格组成</p><h2 id="2-Solution-Sliding-Window"><a href="#2-Solution-Sliding-Window" class="headerlink" title="2 Solution: Sliding Window"></a><span class="label label-info">2 Solution: Sliding Window</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lengthOfLongestSubstring</span>(<span class="hljs-params">self, s</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type s: str</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 初始化左右指针和最大长度</span><br>        l = r = <span class="hljs-number">0</span><br>        maxLen = <span class="hljs-number">0</span><br><br>        <span class="hljs-comment"># 存储字符出现的最后一个索引</span><br>        char_idx = &#123;&#125;<br><br>        <span class="hljs-comment"># 遍历终止条件是右指针移动到字符串最右侧</span><br>        <span class="hljs-keyword">while</span> r &lt; <span class="hljs-built_in">len</span>(s):<br>            <span class="hljs-comment"># 如果字符在当前子串区间内出现过</span><br>            <span class="hljs-keyword">if</span> s[r] <span class="hljs-keyword">in</span> char_idx <span class="hljs-keyword">and</span> char_idx[s[r]] &gt;= l:<br>                <span class="hljs-comment"># 更新左指针，使其跳到重复字符的下一个位置</span><br>                l = char_idx[s[r]] + <span class="hljs-number">1</span><br>            <br>            <span class="hljs-comment"># 更新字符最后一次出现的位置</span><br>            char_idx[s[r]] = r<br>            <span class="hljs-comment"># 更新右指针</span><br>            r += <span class="hljs-number">1</span><br><br>            <span class="hljs-comment"># 计算当前子串的长度</span><br>            current_len = r - l<br>            <span class="hljs-comment"># 更新最大长度</span><br>            maxLen = <span class="hljs-built_in">max</span>(maxLen, current_len)<br><br>        <span class="hljs-keyword">return</span> maxLen<br></code></pre></td></tr></table></figure><p>这段代码实现了求解最长无重复字符子串的问题，采用了滑动窗口的思想。下面是对代码的详细解释：</p><ol><li><p><strong>初始化：</strong></p><ul><li><code>l</code> 和 <code>r</code> 是左右指针，用于构建滑动窗口。</li><li><code>maxLen</code> 用于记录最大的无重复字符子串的长度。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">l = r = <span class="hljs-number">0</span><br>maxLen = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p><strong>存储字符最后一个出现的索引：</strong></p><ul><li><code>char_idx</code> 是一个字典，用于存储字符最后一次出现的索引。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">char_idx = &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>滑动窗口遍历：</strong></p><ul><li><code>while r &lt; len(s):</code> 表示右指针移动到字符串的最右侧为止。</li><li>在每一步迭代中，检查当前字符 <code>s[r]</code> 是否在当前窗口区间内已经出现过。</li><li>如果字符已经出现过且其索引大于等于左指针 <code>l</code>，说明存在重复字符，需要更新左指针 <code>l</code>，使其跳到重复字符的下一个位置。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> s[r] <span class="hljs-keyword">in</span> char_idx <span class="hljs-keyword">and</span> char_idx[s[r]] &gt;= l:<br>    l = char_idx[s[r]] + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p><strong>更新字符最后一次出现的位置：</strong></p><ul><li>将当前字符 <code>s[r]</code> 最后一次出现的位置更新为当前右指针的位置 <code>r</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">char_idx[s[r]] = r<br></code></pre></td></tr></table></figure></li><li><p><strong>更新右指针：</strong></p><ul><li>将右指针 <code>r</code> 向右移动一步。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">r += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p><strong>计算当前子串的长度：</strong></p><ul><li>计算当前子串的长度 <code>current_len</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">current_len = r - l<br></code></pre></td></tr></table></figure></li><li><p><strong>更新最大长度：</strong></p><ul><li>更新 <code>maxLen</code>，如果当前子串的长度 <code>current_len</code> 大于 <code>maxLen</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">maxLen = <span class="hljs-built_in">max</span>(maxLen, current_len)<br></code></pre></td></tr></table></figure></li><li><p><strong>返回最大长度：</strong></p><ul><li>最终返回最长无重复字符子串的长度 <code>maxLen</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">return</span> maxLen<br></code></pre></td></tr></table></figure></li></ol><p>这样，通过滑动窗口的方式，可以在线性时间内解决最长无重复字符子串的问题。</p><h2 id="3-引用"><a href="#3-引用" class="headerlink" title="3 引用"></a><span class="label label-success">3 引用</span></h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">LeetCode 3. 无重复字符的最长子串</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>String</category>
      
      <category>Sliding Window</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>Sliding Window</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 22 括号生成</title>
    <link href="/2024/02/07/LeetCode_22/"/>
    <url>/2024/02/07/LeetCode_22/</url>
    
    <content type="html"><![CDATA[<h2 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="1 问题描述[1]"></a><span class="label label-primary">1 问题描述<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[LeetCode 22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)">[1]</span></a></sup></span></h2><p>Given <code>n</code> pairs of parentheses, write a function to <em>generate all combinations of well-formed parentheses</em>.</p><p> <strong>Example 1:</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Input:</span> n = <span class="hljs-number">3</span><br><span class="hljs-symbol">Output:</span> [<span class="hljs-string">&quot;((()))&quot;</span>,<span class="hljs-string">&quot;(()())&quot;</span>,<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()(())&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">Input:</span> n = <span class="hljs-number">1</span><br><span class="hljs-symbol">Output:</span> [<span class="hljs-string">&quot;()&quot;</span>]<br></code></pre></td></tr></table></figure><p> <strong>Constraints:</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h2 id="2-Solution-Backtrack"><a href="#2-Solution-Backtrack" class="headerlink" title="2 Solution: Backtrack"></a><span class="label label-info">2 Solution: Backtrack</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution2</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generateParenthesis</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">prefix, open_bracket_num, close_bracket_num</span>):<br>            <span class="hljs-comment"># 找到一种有效组合</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prefix) == <span class="hljs-number">2</span> * n:<br>                combinations.append(prefix)<br>                <span class="hljs-keyword">return</span><br><br>            <span class="hljs-comment"># 可以添加 &#x27;(&#x27;</span><br>            <span class="hljs-keyword">if</span> open_bracket_num &lt; n:<br>                backtrack(prefix + <span class="hljs-string">&#x27;(&#x27;</span>, open_bracket_num + <span class="hljs-number">1</span>, close_bracket_num)<br><br>            <span class="hljs-comment"># 可以添加 &#x27;)&#x27;</span><br>            <span class="hljs-keyword">if</span> close_bracket_num &lt; open_bracket_num:<br>                backtrack(prefix + <span class="hljs-string">&#x27;)&#x27;</span>, open_bracket_num, close_bracket_num + <span class="hljs-number">1</span>)<br><br>        combinations = []<br>        backtrack(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> combinations<br></code></pre></td></tr></table></figure><p>这段代码是一个生成括号组合的问题，目标是生成所有有效的括号组合，使得括号按照有效的方式匹配。代码使用了回溯法进行解决。</p><p><strong>代码分析：</strong></p><ol><li><code>generateParenthesis</code> 函数接收一个整数参数 <code>n</code>，表示生成括号组合的对数。</li><li>内部定义了一个嵌套函数 <code>backtrack</code>，该函数采用递归的方式生成所有可能的括号组合。</li><li><code>backtrack</code> 函数接收三个参数：<ul><li><code>prefix</code>：当前正在生成的括号组合的前缀字符串。</li><li><code>open_bracket_num</code>：已经使用的左括号的数量。</li><li><code>close_bracket_num</code>：已经使用的右括号的数量。</li></ul></li><li>如果 <code>prefix</code> 的长度等于 <code>2 * n</code>，则表示找到了一种有效的括号组合，将其添加到 <code>combinations</code> 列表中。</li><li>如果 <code>open_bracket_num</code> 小于 <code>n</code>，则可以添加左括号，递归调用 <code>backtrack</code>。</li><li>如果 <code>close_bracket_num</code> 小于 <code>open_bracket_num</code>，则可以添加右括号，递归调用 <code>backtrack</code>。</li><li>最终，调用 <code>backtrack(&#39;&#39;, 0, 0)</code>，开始生成括号组合，并返回 <code>combinations</code> 列表。</li></ol><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：<code>O(4^n / sqrt(n))</code> ，其中 n 是生成括号组合的对数。这是因为在每个位置上，我们有两种选择，分别是放置左括号或右括号，总共有 <code>2^(2n)</code> 种可能性。然而，由于存在有效性约束，实际有效的组合数量较少，具体的复杂度为卡特兰数，约为 <code>4^n / (sqrt(n))</code> 。</li><li>空间复杂度：<code>O(4^n / sqrt(n))</code> ，主要是递归调用的栈空间和存储结果的列表。除去存储结果的列表之外，空间复杂度主要是由递归调用的栈空间引起的。它是 <code>O(n)</code> 的。</li></ul><p><strong>变体：</strong> 在回溯过程中使用了可变的列表 <code>prefix</code> 代替了不可变的字符串连接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generateParenthesis</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">prefix, open_bracket_num, close_bracket_num</span>):<br>            <span class="hljs-comment"># 找到一种有效组合</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(prefix) == <span class="hljs-number">2</span> * n:<br>                combinations.append(<span class="hljs-string">&#x27;&#x27;</span>.join(prefix))<br>                <span class="hljs-keyword">return</span><br><br>            <span class="hljs-comment"># 可以添加 &#x27;(&#x27;</span><br>            <span class="hljs-keyword">if</span> open_bracket_num &lt; n:<br>                prefix.append(<span class="hljs-string">&#x27;(&#x27;</span>)<br>                backtrack(prefix, open_bracket_num + <span class="hljs-number">1</span>, close_bracket_num)<br>                prefix.pop()<br><br>            <span class="hljs-comment"># 可以添加 &#x27;)&#x27;</span><br>            <span class="hljs-keyword">if</span> close_bracket_num &lt; open_bracket_num:<br>                prefix.append(<span class="hljs-string">&#x27;)&#x27;</span>)<br>                backtrack(prefix, open_bracket_num, close_bracket_num + <span class="hljs-number">1</span>)<br>                prefix.pop()<br><br>        combinations = []<br>        backtrack([], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> combinations<br></code></pre></td></tr></table></figure><p>这两种方案的运行效率差不多，但是测试显示在 Python3 中前者的效率更高点，至于在其他语言中效率优劣如何，需要自己去测试。。</p><p class="note note-success">当 n = 15 时，对应的卡特兰数是 9694845，运行时间如下:<br/>&emsp;&emsp;字符串方案：<br/>&emsp;&emsp;&emsp;&emsp;15.462382078170776s<br/>&emsp;&emsp;列表方案：<br/>&emsp;&emsp;&emsp;&emsp;18.59294891357422s<br/><br/>多次运行均为字符串方案更优</p><h2 id="3-My-First-Solution：递归和动态规划"><a href="#3-My-First-Solution：递归和动态规划" class="headerlink" title="3 My First Solution：递归和动态规划"></a><span class="label label-danger">3 My First Solution：递归和动态规划</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution3</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">generateParenthesis</span>(<span class="hljs-params">self, n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;()&#x27;</span>]<br><br>        prev_combinations = self.generateParenthesis(n-<span class="hljs-number">1</span>)<br>        result = <span class="hljs-built_in">set</span>()<br><br>        <span class="hljs-keyword">for</span> comb <span class="hljs-keyword">in</span> prev_combinations:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(comb) + <span class="hljs-number">1</span>):<br>                result.add(comb[:i] + <span class="hljs-string">&#x27;()&#x27;</span> + comb[i:])<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(result)<br></code></pre></td></tr></table></figure><p>这段代码的目标是生成有效的括号组合，给定括号对数 <code>n</code>。它使用了递归和动态规划的思想。</p><p><strong>代码解释：</strong></p><ol><li>如果 <code>n</code> 等于 1，直接返回包含一个有效括号组合 <code>&#39;()&#39;</code> 的列表 <code>[&#39;()&#39;]</code>。</li><li>对于 <code>n &gt; 1</code> 的情况，首先调用 <code>generateParenthesis(n-1)</code> 来获取 <code>n-1</code> 对括号的有效组合，存储在 <code>prev_combinations</code> 中。</li><li>使用集合 <code>result</code> 来存储当前 <code>n</code> 对括号的有效组合，通过遍历 <code>prev_combinations</code> 中的每个组合，在每个组合的每个位置插入新的一对括号，并将结果添加到 <code>result</code> 中。</li><li>最终，将 <code>result</code> 转换为列表形式，并返回。</li></ol><p><strong>时间复杂度：</strong></p><p>在给定的代码中，有两层嵌套的 for 循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> comb <span class="hljs-keyword">in</span> prev_combinations:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(comb) + <span class="hljs-number">1</span>):<br>        result.add(comb[:i] + <span class="hljs-string">&#x27;()&#x27;</span> + comb[i:])<br></code></pre></td></tr></table></figure><p>分别来分析这两层 for 循环的时间复杂度：</p><ol><li><p><strong>外层循环</strong>：<code>for comb in prev_combinations:</code></p><ul><li>这一层循环遍历了 <code>prev_combinations</code> 中的每一个组合，其中 <code>prev_combinations</code> 包含了 (n-1) 对括号的所有有效组合。</li><li>如果 <code>n</code> 是输入的括号对数，那么 <code>prev_combinations</code> 中的组合数量大致是 <code>O(2^&#123;2n-2&#125;</code>。这是因为每个位置上都有两种选择，而总的括号对数是 (n-1)。</li><li>因此，外层循环的时间复杂度是 <code>O(2^&#123;2n-2&#125;)</code> 。</li></ul></li><li><p><strong>内层循环</strong>：<code>for i in range(len(comb) + 1):</code></p><ul><li>这一层循环遍历了当前组合 <code>comb</code> 的每一个位置，总共有 (2n-1) 个位置。</li><li>在每个位置上，都进行了插入操作，将一对括号插入到组合中。</li><li>因此，内层循环的时间复杂度是 <code>O(2n)</code> 。</li></ul></li></ol><p>综合起来，两层嵌套的 for 循环的总时间复杂度为 <code>O(2^&#123;2n-2&#125; * 2n)</code>，即 <code>O(2^&#123;2n&#125; * n)</code> 。即使外层循环的时间复杂度使用更精确的  <code>O(4^n / sqrt(n))</code> ，整体的时间复杂度也是 <code>O(n * 4^n / sqrt(n))</code> ，比方案1的时间复杂度多了n倍。</p><p class="note note-info">当 n = 15 时，对应的卡特兰数是 9694845，运行时间如下:<br/>&emsp;&emsp;My Solution:<br/>&emsp;&emsp;&emsp;&emsp;77.09048986434937s<br/><br/>明显比上面的方案慢了特别多</p><p><strong>空间复杂度：</strong></p><p>存储结果的列表空间复杂度 <code>O(4^n / sqrt(n))</code> ，同时仍需要存储子问题(n-1)的解，也需要  <code>O(4^n / sqrt(n))</code> 的空间。</p><h2 id="4-引用"><a href="#4-引用" class="headerlink" title="4 引用"></a><span class="label label-success">4 引用</span></h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://leetcode.cn/problems/generate-parentheses/">LeetCode 22. 括号生成</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Backtrack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>Backtrack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 23 合并 K 个升序链表</title>
    <link href="/2024/02/06/LeetCode_23/"/>
    <url>/2024/02/06/LeetCode_23/</url>
    
    <content type="html"><![CDATA[<h2 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="1 问题描述[1]"></a><span class="label label-primary">1 问题描述<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[LeetCode 23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)">[1]</span></a></sup></span></h2><p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p><p><em>Merge all the linked-lists into one sorted linked-list and return it.</em> </p><p><strong>Example 1:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">Input: lists = [[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>]]<br>Output: [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>Explanation: The linked-lists are:<br>[<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>,<br>  <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>,<br>  <span class="hljs-number">2</span>-&gt;<span class="hljs-number">6</span><br>]<br>merging them into one sorted list:<br><span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Input</span>: lists =<span class="hljs-meta"> []</span><br><span class="hljs-attribute">Output</span>:<span class="hljs-meta"> []</span><br></code></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">Input: lists = <span class="hljs-string">[[]]</span><br>Output: []<br></code></pre></td></tr></table></figure><p><strong>Constraints:</strong></p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> is sorted in <strong>ascending order</strong>.</li><li>The sum of <code>lists[i].length</code> will not exceed <code>10^4</code>.</li></ul><h2 id="2-Solution-每轮合并第i个链表到结果链表"><a href="#2-Solution-每轮合并第i个链表到结果链表" class="headerlink" title="2 Solution: 每轮合并第i个链表到结果链表"></a><span class="label label-info">2 Solution: 每轮合并第i个链表到结果链表</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeKLists</span>(<span class="hljs-params">self, lists: <span class="hljs-type">List</span>[<span class="hljs-type">Optional</span>[ListNode]]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">list1, list2</span>):<br>            dummy_head = ListNode()<br>            current_node = dummy_head<br><br>            <span class="hljs-keyword">while</span> list1 <span class="hljs-keyword">and</span> list2:<br>                <span class="hljs-keyword">if</span> list1.val &lt;= list2.val:<br>                    current_node.<span class="hljs-built_in">next</span> = list1<br>                    list1 = list1.<span class="hljs-built_in">next</span><br>                <span class="hljs-keyword">else</span>:<br>                    current_node.<span class="hljs-built_in">next</span> = list2<br>                    list2 = list2.<span class="hljs-built_in">next</span><br><br>                current_node = current_node.<span class="hljs-built_in">next</span><br>            <br>            current_node.<span class="hljs-built_in">next</span> = list1 <span class="hljs-keyword">if</span> list1 <span class="hljs-keyword">else</span> list2<br><br>            <span class="hljs-keyword">return</span> dummy_head.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> lists:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <br>        <span class="hljs-comment"># 初始化结果链表为第一个链表</span><br>        res = lists[<span class="hljs-number">0</span>]<br><br>        <span class="hljs-comment"># 从第二个链表开始，逐一与当前结果链表合并</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(lists)):<br>            <span class="hljs-comment"># 调用 mergeTwoLists 函数，将当前结果链表和第 i 个链表合并</span><br>            res = mergeTwoLists(res, lists[i])<br><br>        <span class="hljs-comment"># 循环结束后，res 包含了所有链表的合并结果</span><br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p>这段代码实现了将K个有序链表合并为一个有序链表的功能。每个链表可能为空。代码中使用了一个辅助函数<code>mergeTwoLists</code>，该函数用于合并两个有序链表。</p><p>首先，定义了一个<code>Solution</code>类，其中包含了两个方法：</p><ol><li><code>mergeTwoLists(list1, list2)</code>：该方法用于合并两个有序链表。</li><li><code>mergeKLists(lists)</code>：该方法用于合并K个有序链表。</li></ol><p>对于<code>mergeTwoLists</code>方法：</p><ul><li>创建一个虚拟头结点<code>dummy_head</code>和一个指向当前结点的指针<code>current_node</code>。</li><li>使用一个循环，比较两个链表的当前结点的值，将较小的值的结点接入合并后的链表，并更新相应的链表指针。</li><li>不断更新<code>current_node</code>指针，直到其中一个链表为空。</li><li>最后，将未遍历完的链表接入合并后的链表。</li></ul><p>对于<code>mergeKLists</code>方法：</p><ul><li>如果输入的<code>lists</code>为空，直接返回<code>None</code>。</li><li>否则，将<code>lists</code>的第一个链表赋值给<code>res</code>作为初始合并结果。</li><li>使用循环遍历<code>lists</code>中的其余链表，依次与<code>res</code>合并，更新<code>res</code>。</li><li>返回最终合并后的链表。</li></ul><p>复杂度分析：</p><ul><li>设k为链表的数量，n为每个链表的最大长度。</li><li>最初，<code>res</code> 的长度为 n。在第一次合并后，<code>res</code> 的长度变为 2n，时间复杂度为 O(2n)。在第二次合并后，<code>res</code> 的长度为 3n，时间复杂度为 O(3n)。依此类推，第 k-1 次合并后，<code>res</code> 的长度为 kn，时间复杂度为 O(kn)。因此，总的时间复杂度为 O(n + 2n + 3n + … + kn) &#x3D; O(n * k^2)。</li><li>空间复杂度为O(1)，没有使用额外的数据结构，只使用了常数级别的额外空间。</li></ul><h2 id="3-Solution-每轮选择一个待排序的最小节点"><a href="#3-Solution-每轮选择一个待排序的最小节点" class="headerlink" title="3 Solution: 每轮选择一个待排序的最小节点"></a><span class="label label-success">3 Solution: 每轮选择一个待排序的最小节点</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeKLists</span>(<span class="hljs-params">self, lists: <span class="hljs-type">List</span>[<span class="hljs-type">Optional</span>[ListNode]]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_min_node</span>(<span class="hljs-params">lists</span>):<br>            min_node = ListNode(<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>))<br>            index = -<span class="hljs-number">1</span><br><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(lists)):<br>                <span class="hljs-keyword">if</span> lists[i] <span class="hljs-keyword">and</span> lists[i].val &lt; min_node.val:<br>                    min_node = lists[i]<br>                    index = i<br>            <br>            <span class="hljs-keyword">return</span> min_node, index<br><br>        dummy_head = ListNode()<br>        current_node = dummy_head<br><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            min_node, index = get_min_node(lists)<br><br>            <span class="hljs-keyword">if</span> index == -<span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">break</span>  <span class="hljs-comment"># 所有链表均为 None，结束循环</span><br>            <br>            current_node.<span class="hljs-built_in">next</span> = min_node<br>            current_node = current_node.<span class="hljs-built_in">next</span><br>            lists[index] = lists[index].<span class="hljs-built_in">next</span><br><br>        <span class="hljs-keyword">return</span> dummy_head.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><p>在这个简单的顺序合并的算法中，每一轮从 K 个链表中选出最小节点加入到结果链表中，直到所有链表均为 None。让我们分析一下时间和空间复杂度。</p><ol><li><p><strong>时间复杂度：</strong></p><ul><li>在每一轮中，我们需要遍历 K 个链表，找到当前轮次中的最小节点。这需要 O(K) 的时间。</li><li>如果每个链表的平均长度是 n，那么在 K 个链表中，总共有 K * n 个节点。在最坏情况下，每个节点都需要进行比较。因此，每轮比较的时间复杂度是 O(K * n)。</li><li>总共有 K 轮，所以总的时间复杂度为 O(K^2 * n)。</li></ul></li><li><p><strong>空间复杂度：</strong></p><ul><li>需要额外的空间存储结果链表，以及一些辅助变量（例如 <code>dummy_head</code>、<code>current_node</code>）。</li><li>不考虑输入数据本身，空间复杂度是 O(1)。</li></ul></li></ol><p>在这个简单实现中，时间复杂度主要受到 K 轮比较的影响。如果 K 比较小，这个算法可能是合适的。但是，如果 K 较大，效率可能不够高。在实际应用中，有更优化的算法可以进一步降低时间复杂度。</p><h2 id="4-Solution-分治合并"><a href="#4-Solution-分治合并" class="headerlink" title="4 Solution: 分治合并"></a><span class="label label-warning">4 Solution: 分治合并</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeKLists</span>(<span class="hljs-params">self, lists: <span class="hljs-type">List</span>[<span class="hljs-type">Optional</span>[ListNode]]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeTwoLists</span>(<span class="hljs-params">list1, list2</span>):<br>            dummy_head = ListNode()<br>            current_node = dummy_head<br><br>            <span class="hljs-keyword">while</span> list1 <span class="hljs-keyword">and</span> list2:<br>                <span class="hljs-keyword">if</span> list1.val &lt;= list2.val:<br>                    current_node.<span class="hljs-built_in">next</span> = list1<br>                    list1 = list1.<span class="hljs-built_in">next</span><br>                <span class="hljs-keyword">else</span>:<br>                    current_node.<span class="hljs-built_in">next</span> = list2<br>                    list2 = list2.<span class="hljs-built_in">next</span><br><br>                current_node = current_node.<span class="hljs-built_in">next</span><br>            <br>            current_node.<span class="hljs-built_in">next</span> = list1 <span class="hljs-keyword">if</span> list1 <span class="hljs-keyword">else</span> list2<br><br>            <span class="hljs-keyword">return</span> dummy_head.<span class="hljs-built_in">next</span><br>        <br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeListsInRange</span>(<span class="hljs-params">start, stop</span>):<br>            <span class="hljs-keyword">if</span> start == stop:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>            <span class="hljs-keyword">elif</span> stop - start == <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">return</span> lists[start]<br>            <span class="hljs-keyword">else</span>:<br>                middle = (start + stop) // <span class="hljs-number">2</span><br>                <span class="hljs-keyword">return</span> mergeTwoLists(mergeListsInRange(start, middle), mergeListsInRange(middle, stop))<br>            <br>        <span class="hljs-keyword">return</span> mergeListsInRange(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(lists))<br></code></pre></td></tr></table></figure><p>这段代码实现了合并 K 个排序链表的功能。具体解释如下：</p><ol><li><p><code>mergeTwoLists(list1, list2)</code>: 这个函数用于合并两个有序链表，其中 <code>list1</code> 和 <code>list2</code> 分别表示两个链表的头结点。它通过比较节点的值，逐个选择较小的节点进行合并，并移动相应链表的指针。最后，将合并后的链表返回。</p></li><li><p><code>mergeListsInRange(start, stop)</code>: 这个递归函数用于合并 <code>lists</code> 列表中从 <code>start</code> 到 <code>stop - 1</code> 索引范围内的有序链表。它通过不断二分 <code>lists</code> 列表，调用 <code>mergeTwoLists</code> 函数逐层合并，直到最终合并为一个有序链表。</p></li><li><p><code>mergeKLists(lists)</code>: 这个是主函数，通过调用 <code>mergeListsInRange</code> 函数，将整个 <code>lists</code> 列表中的有序链表进行合并。</p></li></ol><p>复杂度分析：</p><ul><li><p>时间复杂度：假设有 K 个链表，每个链表的平均长度为 N。在每一层递归中，需要遍历所有链表的节点进行合并，所以每一层的时间复杂度为 O(N<em>K)。递归的层数为 log(K)，因为每次都是将 K 个链表二分，所以总的时间复杂度为 O(N</em>K*log(K))。</p><p>可以参考该图：</p><img src="/2024/02/06/LeetCode_23/divideandconquer.png" class=""></li><li><p>空间复杂度：主要消耗的是递归调用的栈空间。由于每次递归都是对 K 个链表进行二分，所以递归栈的最大深度为 log(K)。最终空间复杂度O(log(K))。</p></li></ul><h2 id="5-Solution-优先队列"><a href="#5-Solution-优先队列" class="headerlink" title="5 Solution: 优先队列"></a><span class="label label-danger">5 Solution: 优先队列</span></h2><h3 id="5-1-Python-Version"><a href="#5-1-Python-Version" class="headerlink" title="5.1 Python Version"></a><span class="label label-danger">5.1 Python Version</span></h3><p class="note note-info">TODO: 堆/优先队列，例如如何建堆，时间复杂度是多少，如何插入数据弹出数据？如何自己实现堆？<br/>请学习MIT6.006 Introduce To Algorithms Lecture 8: Binary Heaps<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[MIT6.006 Introduce To Algorithms Lecture 8: Binary Heaps](https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-spring-2020/resources/lecture-8-binary-heaps/)">[2]</span></a></sup></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> heapq<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span>, <span class="hljs-type">Optional</span><br><br><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, val=<span class="hljs-number">0</span>, <span class="hljs-built_in">next</span>=<span class="hljs-literal">None</span></span>):<br>        self.val = val<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span><br>        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mergeKLists</span>(<span class="hljs-params">self, lists: <span class="hljs-type">List</span>[<span class="hljs-type">Optional</span>[ListNode]]</span>) -&gt; <span class="hljs-type">Optional</span>[ListNode]:<br>        <span class="hljs-comment"># 创建一个最小堆</span><br>        heap = []<br><br>        <span class="hljs-comment"># 将每个链表的第一个节点加入最小堆</span><br>        <span class="hljs-keyword">for</span> i, lst <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(lists):<br>            <span class="hljs-keyword">if</span> lst:<br>                <span class="hljs-comment"># heapq 模块默认会按照元组的第一个元素进行比较，然后是第二个元素，以此类推</span><br>                heapq.heappush(heap, (lst.val, i, lst))<br><br>        <span class="hljs-comment"># 创建一个虚拟头节点</span><br>        dummy_head = ListNode()<br>        current_node = dummy_head<br><br>        <span class="hljs-comment"># 循环直到最小堆为空</span><br>        <span class="hljs-keyword">while</span> heap:<br>            <span class="hljs-comment"># 弹出最小堆中的最小节点</span><br>            val, i, node = heapq.heappop(heap)<br><br>            <span class="hljs-comment"># 将当前节点接入结果链表</span><br>            current_node.<span class="hljs-built_in">next</span> = node<br>            current_node = current_node.<span class="hljs-built_in">next</span><br><br>            <span class="hljs-comment"># 如果被弹出的节点还有下一个节点，将下一个节点加入最小堆</span><br>            <span class="hljs-keyword">if</span> node.<span class="hljs-built_in">next</span>:<br>                heapq.heappush(heap, (node.<span class="hljs-built_in">next</span>.val, i, node.<span class="hljs-built_in">next</span>))<br>        <br>        <span class="hljs-comment"># 返回合并后链表的头节点</span><br>        <span class="hljs-keyword">return</span> dummy_head.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><p>这段代码实现了合并 k 个有序链表的操作，使用了最小堆（heapq）来维护当前 k 个链表中最小的节点。</p><p>以下是对代码的解释和复杂度分析：</p><ol><li><strong>最小堆的创建：</strong><ul><li>创建一个空的最小堆 <code>heap</code>，用于存储每个链表的第一个节点。堆中的元素是三元组 <code>(节点值, 链表索引, 节点)</code>。</li><li>循环遍历输入的链表列表 <code>lists</code>，如果链表非空，则将链表的第一个节点加入最小堆。</li></ul></li><li><strong>合并过程：</strong><ul><li>创建一个虚拟头节点 <code>dummy_head</code> 和一个指向当前节点的指针 <code>current_node</code>，用于构建合并后的链表。</li><li>进入一个循环，循环条件是最小堆不为空。<ul><li>在每一步迭代中，从最小堆中弹出最小的节点（堆顶元素），将其接入合并后的链表。</li><li>如果被弹出的节点有下一个节点，则将下一个节点加入最小堆。</li><li>继续循环，直到最小堆为空。</li></ul></li></ul></li><li><strong>返回结果：</strong><ul><li>返回合并后链表的头节点，即 <code>dummy_head.next</code>。</li></ul></li></ol><p><strong>复杂度分析：</strong></p><ul><li>堆操作的时间复杂度：每个节点都可能被插入和弹出堆一次，因此堆操作的总时间复杂度是 O(N * log(k))，其中 N 是所有节点的总数，k 是链表的数量。</li><li>空间复杂度：额外使用了一个最小堆来存储节点，因此空间复杂度是 O(k)。</li></ul><p>综合考虑，总体的时间复杂度为 O(N * log(k))，这里的 <code>N</code> 是所有链表节点的数量，空间复杂度为 O(k)。</p><h3 id="5-2-Java-Version"><a href="#5-2-Java-Version" class="headerlink" title="5.2 Java Version"></a><span class="label label-danger">5.2 Java Version</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>    <span class="hljs-comment">// 创建一个最小堆(优先队列)，按节点值比较</span><br>    PriorityQueue&lt;ListNode&gt; minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(a -&gt; a.val));<br><br>    <span class="hljs-comment">// 将每个链表的第一个节点添加到最小堆</span><br>    <span class="hljs-keyword">for</span> (ListNode list : lists) &#123;<br>        <span class="hljs-keyword">if</span> (list != <span class="hljs-literal">null</span>) &#123;<br>            minHeap.add(list);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建一个虚拟头节点和当前节点指针</span><br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> dummyHead;<br><br>    <span class="hljs-comment">// 循环直到最小堆为空</span><br>    <span class="hljs-keyword">while</span> (!minHeap.isEmpty()) &#123;<br>        <span class="hljs-comment">// 弹出最小节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> minHeap.poll();<br><br>        <span class="hljs-comment">// 将最小节点加入到结果链表</span><br>        current.next = node;<br>        current = current.next;<br><br>        <span class="hljs-comment">// 如果被弹出的节点还有下一个节点，将下一个节点加入最小堆</span><br>        <span class="hljs-keyword">if</span> (node.next != <span class="hljs-literal">null</span>) &#123;<br>            minHeap.add(node.next);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dummyHead.next;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-Addition"><a href="#6-Addition" class="headerlink" title="6 Addition"></a><span class="label label-default">6 Addition</span></h2><h3 id="数据结构中的heap-vs-内存中的heap"><a href="#数据结构中的heap-vs-内存中的heap" class="headerlink" title="数据结构中的heap vs 内存中的heap"></a>数据结构中的heap vs 内存中的heap</h3><p>虽然它们都被称为“堆”（heap），但在计算机科学中，数据结构中的堆（heap）和内存中的堆（heap）指的是完全不同的概念。</p><ol><li><p><strong>数据结构中的堆（Heap，优先队列）：</strong></p><ul><li>数据结构中的堆通常指的是一种特殊的树形数据结构，被称为二叉堆，它有两种类型：最大堆和最小堆。</li><li>在最小堆中，每个节点的值都小于或等于其子节点的值。在最大堆中，每个节点的值都大于或等于其子节点的值。</li><li>堆常常用于实现优先队列，其中具有较小（或较大）值的元素具有更高的优先级。Python中的<code>heapq</code>模块就是使用最小堆来实现的。</li><li>堆的操作包括插入元素、删除最小元素等，这些操作的时间复杂度较低，使得堆非常适用于需要快速找到最小（或最大）元素的场景。</li></ul></li><li><p><strong>内存中的堆（Heap Memory）：</strong></p><ul><li>内存中的堆是一块用于动态分配内存的区域。当程序运行时，需要动态分配内存来存储数据，这些数据的大小在编译时不能确定。</li><li>堆内存允许程序员在运行时动态地分配和释放内存。通过 <code>malloc</code>（C语言）、<code>new</code>（C++）、<code>malloc</code> 或 <code>calloc</code>（C）等操作，程序可以在堆中申请一块内存区域。</li><li>堆中的内存由程序员负责管理，需要手动释放以防止内存泄漏。在某些语言中，有垃圾回收机制（如Java、Python等），它们可以自动管理堆内存的分配和释放。</li></ul></li></ol><p>总结：尽管两者都称为“堆”，但它们是两个不同的概念。数据结构中的堆是一种特殊的树形数据结构，而内存中的堆是用于动态分配内存的区域。</p><h2 id="7-引用"><a href="#7-引用" class="headerlink" title="7 引用"></a><span class="label label-success">7 引用</span></h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">LeetCode 23. 合并 K 个升序链表</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-spring-2020/resources/lecture-8-binary-heaps/">MIT6.006 Introduce To Algorithms Lecture 8: Binary Heaps</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Divide and Conquer</category>
      
      <category>Data Structure</category>
      
      <category>Priority Queue(Heap)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>Java</tag>
      
      <tag>Divide and Conquer</tag>
      
      <tag>Priority Queue(Heap)</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 10 正则表达式匹配</title>
    <link href="/2024/02/06/LeetCode_10/"/>
    <url>/2024/02/06/LeetCode_10/</url>
    
    <content type="html"><![CDATA[<h2 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="1 问题描述[1]"></a><span class="label label-primary">1 问题描述<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[LeetCode 10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/description/)">[1]</span></a></sup></span></h2><p>Given an input string <code>s</code> and a pattern <code>p</code>, implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code> where:</p><ul><li><code>&#39;.&#39;</code> Matches any single character.</li><li><code>&#39;*&#39;</code> Matches zero or more of the preceding element.</li></ul><p>The matching should cover the <strong>entire</strong> input string (not partial).</p><p><strong>Example 1:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">Input:</span> s = <span class="hljs-string">&quot;aa&quot;</span>, p = <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-symbol">Output:</span> <span class="hljs-literal">false</span><br><span class="hljs-symbol">Explanation:</span> <span class="hljs-string">&quot;a&quot;</span> does <span class="hljs-built_in">not</span> match the entire <span class="hljs-type">string</span> <span class="hljs-string">&quot;aa&quot;</span>.<br></code></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Input: s = <span class="hljs-string">&quot;aa&quot;</span>, p = <span class="hljs-string">&quot;a*&quot;</span><br>Output: <span class="hljs-literal">true</span><br>Explanation: <span class="hljs-string">&#x27;*&#x27;</span> means <span class="hljs-literal">zero</span> <span class="hljs-keyword">or</span> more <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> preceding <span class="hljs-keyword">element</span>, <span class="hljs-string">&#x27;a&#x27;</span>. Therefore, <span class="hljs-keyword">by</span> repeating <span class="hljs-string">&#x27;a&#x27;</span> once, <span class="hljs-keyword">it</span> becomes <span class="hljs-string">&quot;aa&quot;</span>.<br></code></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">Input:</span> s = <span class="hljs-string">&quot;ab&quot;</span>, p = <span class="hljs-string">&quot;.*&quot;</span><br><span class="hljs-symbol">Output:</span> <span class="hljs-literal">true</span><br><span class="hljs-symbol">Explanation:</span> <span class="hljs-string">&quot;.*&quot;</span> means <span class="hljs-string">&quot;zero or more (*) of any character (.)&quot;</span>.<br></code></pre></td></tr></table></figure><p><strong>出错过的用例:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">Input:</span> s = <span class="hljs-string">&quot;abc&quot;</span>, p = <span class="hljs-string">&quot;c*abc&quot;</span><br><span class="hljs-symbol">Output:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>特殊用例:</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Input: s = <span class="hljs-string">&quot;abc&quot;</span>, p = <span class="hljs-string">&quot;a***abc&quot;</span>     <span class="hljs-keyword">a</span>***abc可以拆分成 <span class="hljs-string">&#x27;a* ** bc&#x27;</span>, 连续的两个**可以匹配<span class="hljs-string">&#x27;&#x27;</span>(<span class="hljs-literal">null</span> <span class="hljs-keyword">string</span>)<br>Output: <span class="hljs-literal">true</span><br>从这个用例，在写程序的时，意识到**是可以在模式串中存在的就可以了。<br><br>Input: s = <span class="hljs-string">&quot;abc&quot;</span>, p = <span class="hljs-string">&quot;a**abc&quot;</span> <span class="hljs-keyword">a</span>**abc 没有意义，第二个 * 没有前面的元素可以匹配<br>Output: <span class="hljs-literal">false</span> <br></code></pre></td></tr></table></figure><p> <strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>1 &lt;= p.length &lt;= 20</code></li><li><code>s</code> contains only lowercase English letters.</li><li><code>p</code> contains only lowercase English letters, <code>&#39;.&#39;</code>, and <code>&#39;*&#39;</code>.</li><li>It is guaranteed for each appearance of the character <code>&#39;*&#39;</code>, there will be a previous valid character to match.</li></ul><h2 id="2-Solution-Dynamic-Programming"><a href="#2-Solution-Dynamic-Programming" class="headerlink" title="2 Solution: Dynamic Programming"></a><span class="label label-info">2 Solution: Dynamic Programming</span></h2><h3 id="2-1-Top-Down-Variation"><a href="#2-1-Top-Down-Variation" class="headerlink" title="2.1 Top-Down Variation"></a><span class="label label-success">2.1 Top-Down Variation</span></h3><h4 id="2-1-1-LeetCode-Solution"><a href="#2-1-1-LeetCode-Solution" class="headerlink" title="2.1.1 LeetCode Solution"></a><span class="label label-success">2.1.1 LeetCode Solution</span></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isMatch</span>(<span class="hljs-params">self, text: <span class="hljs-built_in">str</span>, pattern: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        memo = &#123;&#125;<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dp</span>(<span class="hljs-params">ti, pi</span>):<br>            <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            Function: Check if text[ti:] matches pattern[pi:]</span><br><span class="hljs-string">            Parameters:</span><br><span class="hljs-string">                ti: int, text index</span><br><span class="hljs-string">                pi: int, pattern index</span><br><span class="hljs-string">            Returns:</span><br><span class="hljs-string">                bool: True if match, False otherwise</span><br><span class="hljs-string">            &quot;&quot;&quot;</span><br>            <span class="hljs-keyword">if</span> (ti, pi) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> memo:<br>                <span class="hljs-comment"># base case</span><br>                <span class="hljs-keyword">if</span> pi == <span class="hljs-built_in">len</span>(pattern):<br>                    ans = ti == <span class="hljs-built_in">len</span>(text)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># first_match: text和pattern的第一个字符匹配吗？</span><br>                    first_match = ti &lt; <span class="hljs-built_in">len</span>(text) <span class="hljs-keyword">and</span> pattern[pi] <span class="hljs-keyword">in</span> &#123;text[ti], <span class="hljs-string">&#x27;.&#x27;</span>&#125;<br><br>                    <span class="hljs-comment"># case: &#x27;*&#x27;</span><br>                    <span class="hljs-keyword">if</span> pi + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(pattern) <span class="hljs-keyword">and</span> pattern[pi + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>:<br>                        ans = dp(ti, pi + <span class="hljs-number">2</span>) <span class="hljs-keyword">or</span> (first_match <span class="hljs-keyword">and</span> dp(ti + <span class="hljs-number">1</span>, pi))<br>                    <span class="hljs-comment"># case: &#x27;.&#x27; and ordinary char</span><br>                    <span class="hljs-keyword">else</span>:<br>                        ans = first_match <span class="hljs-keyword">and</span> dp(ti + <span class="hljs-number">1</span>, pi + <span class="hljs-number">1</span>)<br><br>                memo[(ti, pi)] = ans<br><br>            <span class="hljs-keyword">return</span> memo[(ti, pi)]<br><br>        <span class="hljs-keyword">return</span> dp(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>这段代码是一个实现正则表达式匹配的算法，使用了动态规划的思想。主要是通过递归函数<code>dp</code>来判断给定的<code>text</code>和<code>pattern</code>是否匹配。</p><p>下面是对代码的详细解释：</p><ol><li><p><code>memo</code>是一个字典，用于存储已经计算过的子问题的结果，避免重复计算，提高算法效率。</p></li><li><p><code>dp</code>函数是递归函数，用于检查<code>text[ti:]</code>是否匹配<code>pattern[pi:]</code>。</p></li><li><p>在函数内部，首先检查<code>(ti, pi)</code>是否已经在<code>memo</code>中，如果在，则直接返回之前计算的结果。</p></li><li><p>如果<code>(ti, pi)</code>不在<code>memo</code>中，首先判断基本情况，即如果<code>pi</code>等于<code>pattern</code>的长度，那么结果为<code>ti</code>是否等于<code>text</code>的长度。也就是说，如果<code>pattern</code>已经遍历完，那么<code>text</code>也必须遍历完才算匹配。</p><p>因为在非基本情况中，<code>ti</code> 和 <code>pi</code> 会变大，所以最终会遇到 <code>text[len(text):]</code> <code>pattern[len(pattern):]</code>即被匹配的<code>text</code> <code>pattern</code> 为 <code>&#39;&#39;</code>的情况。</p><table><thead><tr><th align="center"></th><th align="center">pattern &#x3D; ‘’</th><th align="center">pattern !&#x3D; ‘’</th></tr></thead><tbody><tr><td align="center">text &#x3D; ‘’</td><td align="center">匹配</td><td align="center">需要判断</td></tr><tr><td align="center">text !&#x3D; ‘’</td><td align="center">不匹配</td><td align="center">需要判断</td></tr></tbody></table><ul><li><p>当 <code>text = &#39;&#39;, pattern= &#39;c*c*&#39;</code> 时，匹配。</p></li><li><p>当 <code>text = &#39;&#39;, pattern= &#39;a&#39;</code> 时，不匹配，所以需要判断。</p></li></ul></li><li><p>如果<code>pi</code>不等于<code>pattern</code>的长度，接下来判断第一个字符是否匹配。定义<code>first_match</code>表示<code>text</code>和<code>pattern</code>的第一个字符是否匹配，它取决于当前字符和<code>&#39;.&#39;</code>是否相等。</p></li><li><p>如果下一个字符是<code>&#39;*&#39;</code>，则有两种情况：</p><ul><li>不使用<code>&#39;*&#39;</code>，即<code>dp(ti, pi + 2)</code>，表示<code>&#39;*&#39;</code>前面的字符在<code>text</code>中出现0次。</li><li>使用<code>&#39;*&#39;</code>，即<code>(first_match and dp(ti + 1, pi))</code>，表示<code>&#39;*&#39;</code>前面的字符在<code>text</code>中出现至少1次，递归检查剩下的部分。</li></ul></li><li><p>如果下一个字符不是<code>&#39;*&#39;</code>，则简单地匹配当前字符，即<code>first_match and dp(ti + 1, pi + 1)</code>。</p></li><li><p>将计算结果存入<code>memo</code>，然后返回结果。</p></li><li><p>最终调用<code>dp(0, 0)</code>，从<code>text</code>和<code>pattern</code>的开头开始检查匹配关系。</p></li></ol><p>总体来说，这是一个使用动态规划思想的递归算法，通过存储子问题的解避免了重复计算，提高了算法效率。</p><h4 id="2-1-2-My-Solution"><a href="#2-1-2-My-Solution" class="headerlink" title="2.1.2 My Solution"></a><span class="label label-success">2.1.2 My Solution</span></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isMatch</span>(<span class="hljs-params">self, text: <span class="hljs-built_in">str</span>, pattern: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        memo = &#123;&#125;<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_char_match</span>(<span class="hljs-params">text_char, pattern_char</span>):<br>            <span class="hljs-keyword">return</span> pattern_char == <span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-keyword">or</span> text_char == pattern_char<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">recursive_match</span>(<span class="hljs-params">text_index, pattern_index</span>):<br>            <span class="hljs-keyword">if</span> (text_index, pattern_index) <span class="hljs-keyword">in</span> memo:<br>                <span class="hljs-keyword">return</span> memo[(text_index, pattern_index)]<br><br>            <span class="hljs-comment"># base case</span><br>            <span class="hljs-keyword">if</span> pattern_index == <span class="hljs-built_in">len</span>(pattern):<br>                result =  text_index == <span class="hljs-built_in">len</span>(text)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># case: &#x27;*&#x27;</span><br>                <span class="hljs-keyword">if</span> pattern_index + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(pattern) <span class="hljs-keyword">and</span> pattern[pattern_index + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>:<br>                    i, previous_char = <span class="hljs-number">0</span>, pattern[pattern_index]<br>                    <span class="hljs-comment"># 匹配0次*之前的字符</span><br>                    result = recursive_match(text_index, pattern_index + <span class="hljs-number">2</span>)<br><br>                    <span class="hljs-comment"># 匹配多次*之前的字符</span><br>                    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> result <span class="hljs-keyword">and</span> text_index + i &lt; <span class="hljs-built_in">len</span>(text) <span class="hljs-keyword">and</span> is_char_match(text[text_index + i], previous_char):<br>                        result = recursive_match(text_index + i + <span class="hljs-number">1</span>, pattern_index + <span class="hljs-number">2</span>)<br>                        i += <span class="hljs-number">1</span><br>                <span class="hljs-comment"># case: &#x27;.&#x27; &#x27;c&#x27;</span><br>                <span class="hljs-keyword">else</span>:<br>                    result = text_index &lt; <span class="hljs-built_in">len</span>(text) <span class="hljs-keyword">and</span> is_char_match(text[text_index], pattern[pattern_index]) <span class="hljs-keyword">and</span> recursive_match(text_index + <span class="hljs-number">1</span>, pattern_index + <span class="hljs-number">1</span>)<br><br>            memo[(text_index, pattern_index)] = result<br>            <span class="hljs-keyword">return</span> result<br><br>        <span class="hljs-keyword">return</span> recursive_match(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>这段代码与上面代码的不同在于当遇到 <code>&#39;*&#39;</code> 时的处理，假设在计算 <code>dp(ti, pi)</code> 时，<code>pattern[pi + 2]</code> 是 <code>&#39;*&#39;</code> , <code>LeetCode</code> 的处理逻辑是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dp(ti, pi) = dp(ti, pi + <span class="hljs-number">2</span>) <span class="hljs-keyword">or</span> (first_match <span class="hljs-keyword">and</span> dp(ti + <span class="hljs-number">1</span>, pi))<br></code></pre></td></tr></table></figure><p>一个大问题被拆分成了两个子问题。</p><p><code>My Solution</code> 的处理逻辑是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 匹配0次*之前的字符</span><br>result = recursive_match(text_index, pattern_index + <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 匹配多次*之前的字符</span><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> result <span class="hljs-keyword">and</span> text_index + i &lt; <span class="hljs-built_in">len</span>(text) <span class="hljs-keyword">and</span> is_char_match(text[text_index + i], previous_char):<br>    result = recursive_match(text_index + i + <span class="hljs-number">1</span>, pattern_index + <span class="hljs-number">2</span>)<br>    i += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>采用了一个 <code>while</code> 循环来迭代匹配多次 <code>&#39;*&#39;</code> 前的字符，一个大问题在极端情况下至多被拆分成了 <code>len(text)</code> 个子问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dp(ti, pi) = dp(ti, pi + <span class="hljs-number">2</span>) <span class="hljs-keyword">or</span> dp(ti + <span class="hljs-number">1</span>, pi + <span class="hljs-number">2</span>) ..... <span class="hljs-keyword">or</span> dp(<span class="hljs-built_in">len</span>(text) + <span class="hljs-number">1</span>, pi + <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h4 id="2-1-3-LeetCode-vs-Mine-代码效率比较"><a href="#2-1-3-LeetCode-vs-Mine-代码效率比较" class="headerlink" title="2.1.3 LeetCode vs Mine - 代码效率比较"></a><span class="label label-success">2.1.3 LeetCode vs Mine - 代码效率比较</span></h4><p>为了测试两段代码在极端情况下的效率差异，我们使用以下测试数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">text = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">500</span><br>pattern = <span class="hljs-string">&quot;a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*c&quot;</span><br><br>My Solution:<br>dp() 调用次数: <span class="hljs-number">2</span>,<span class="hljs-number">515</span>,<span class="hljs-number">522</span> | memo 命中次数: <span class="hljs-number">2</span>,<span class="hljs-number">505</span>,<span class="hljs-number">000</span> | memo 大小: <span class="hljs-number">10</span>,<span class="hljs-number">522</span><br>时间: <span class="hljs-number">2.51</span> 秒<br><br>LeetCode Solution:<br>dp() 调用次数: <span class="hljs-number">21</span>,023 | memo 命中次数: <span class="hljs-number">10</span>,001 | memo 大小: <span class="hljs-number">11</span>,022<br>时间: <span class="hljs-number">0.02</span> 秒<br></code></pre></td></tr></table></figure><ul><li><p><strong><code>memo size</code> 比较：</strong> 两者几乎相同，表明解决的子问题数量相近。假设 <code>text</code> 长度为 <code>M</code>，<code>pattern</code> 长度为 <code>N</code>，则计算 <code>dp(0, 0)</code> 需要解决的子问题规模约为 <code>M * N</code>。</p></li><li><p><strong><code>dp()</code> 调用次数比较：</strong> “My Solution” 中的 <code>dp()</code> 调用次数是 “LeetCode Solution” 的125倍（2,515,522 对比 21,023）。这说明 “My Solution” 中存在大量重复的子问题。</p></li><li><p><strong><code>time</code> 比较：</strong> “My Solution” 的执行时间也是 “LeetCode Solution” 的125倍。</p></li></ul><p>因此， “My Solution” 的问题主要出在 <code>dp()</code> 被调用的重复子问题数量过多。</p><p>在分析子问题调用次数问题之前，我们来看一下两个程序的执行结果：</p><p><strong>My Solution</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">text = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">5</span><br>pattern = <span class="hljs-string">&quot;a*a*a*a*a*c&quot;</span><br><br><span class="hljs-comment"># dp[ti][pi] 表示子问题 dp(ti, pi) 的调用次数，执行 dp(0, 0) 后数组如下：</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 子问题的解决顺序</span><br>[<span class="hljs-number">31</span>, <span class="hljs-number">0</span>, <span class="hljs-number">25</span>, <span class="hljs-number">0</span>, <span class="hljs-number">19</span>, <span class="hljs-number">0</span>, <span class="hljs-number">13</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">26</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">14</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">27</span>, <span class="hljs-number">0</span>, <span class="hljs-number">21</span>, <span class="hljs-number">0</span>, <span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">28</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0</span>, <span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">29</span>, <span class="hljs-number">0</span>, <span class="hljs-number">23</span>, <span class="hljs-number">0</span>, <span class="hljs-number">17</span>, <span class="hljs-number">0</span>, <span class="hljs-number">11</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">30</span>, <span class="hljs-number">0</span>, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>, <span class="hljs-number">18</span>, <span class="hljs-number">0</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>一个大问题最多依赖 <code>M</code> 个子问题，一个子问题最多被 <code>M</code> 个大问题调用。</p><table><thead><tr><th align="center"></th><th align="center">a</th><th align="center">*</th><th align="center">a</th><th align="center">*</th><th align="center">a</th><th align="center">*</th><th align="center">a</th><th align="center">*</th><th>a</th><th align="center">*</th><th align="center">c</th><th>‘’</th></tr></thead><tbody><tr><td align="center">a</td><td align="center">dp(0, 0)</td><td align="center"></td><td align="center">X</td><td align="center"></td><td align="center">x</td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center">Y</td><td align="center"></td><td align="center">x</td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center">Z</td><td align="center"></td><td align="center">x</td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center">P</td><td align="center"></td><td align="center">x</td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center">R</td><td align="center"></td><td align="center">x</td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center">‘’</td><td align="center"></td><td align="center"></td><td align="center">S</td><td align="center"></td><td align="center">x,y,z,p,r,s</td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td></td></tr></tbody></table><p>在上面的表格中，大问题 <code>X dp(0, 2)</code> 依赖 <code>M</code> 个子问题 <code>x</code> ，子问题 <code>x dp(5, 4)</code>  最多被 <code>M</code> 个大问题 <code>X Y Z P R S</code> 依赖，子问题的规模是 <code>M * N</code> ，每个子问题最多被调用 <code>M</code> 次，所以最终时间复杂度是 <code>O(M^2 * N)</code>。</p><p><strong>LeetCode Solution</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">text = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">5</span><br>pattern = <span class="hljs-string">&quot;a*a*a*a*a*c&quot;</span><br><br><span class="hljs-comment"># dp[ti][pi] 表示子问题 dp(ti, pi) 的调用次数，执行 dp(0, 0) 后数组如下：</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 子问题的解决顺序</span><br>[<span class="hljs-number">36</span>, <span class="hljs-number">0</span>, <span class="hljs-number">30</span>, <span class="hljs-number">0</span>, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>, <span class="hljs-number">18</span>, <span class="hljs-number">0</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">35</span>, <span class="hljs-number">0</span>, <span class="hljs-number">29</span>, <span class="hljs-number">0</span>, <span class="hljs-number">23</span>, <span class="hljs-number">0</span>, <span class="hljs-number">17</span>, <span class="hljs-number">0</span>, <span class="hljs-number">11</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">34</span>, <span class="hljs-number">0</span>, <span class="hljs-number">28</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0</span>, <span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">33</span>, <span class="hljs-number">0</span>, <span class="hljs-number">27</span>, <span class="hljs-number">0</span>, <span class="hljs-number">21</span>, <span class="hljs-number">0</span>, <span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">32</span>, <span class="hljs-number">0</span>, <span class="hljs-number">26</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">14</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">31</span>, <span class="hljs-number">0</span>, <span class="hljs-number">25</span>, <span class="hljs-number">0</span>, <span class="hljs-number">19</span>, <span class="hljs-number">0</span>, <span class="hljs-number">13</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>一个大问题至多依赖两个子问题，一个子问题至多被两个大问题调用。</p><table><thead><tr><th align="center"></th><th align="center">a</th><th align="center">*</th><th align="center">a</th><th align="center">*</th><th align="center">a</th><th align="center">*</th><th align="center">a</th><th align="center">*</th><th align="center">a</th><th align="center">*</th><th align="center">c</th><th align="center">‘’</th></tr></thead><tbody><tr><td align="center">a</td><td align="center">dp(0,0)</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">Y</td><td align="center">y</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">X: dp(1, 4)</td><td align="center"></td><td align="center">x,y: dp(1, 6)</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">x: dp(2, 4)</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">‘’</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>在上面的表格中，大问题 <code>X dp(1, 4)</code> 依赖两个子问题 <code>x dp(2, 4)</code> <code>x dp(1, 6)</code> ，子问题 <code>dp(1, 6)</code>  至多被两个大问题 <code>X Y</code> 依赖，子问题的规模是 <code>M * N</code> ，每个子问题最多被调用两次，所以最终时间复杂度是 <code>O(M * N)</code>。</p><p><strong>结论：</strong> 在递归算法中，大问题对子问题的依赖数量越少越好。较少的依赖意味着解决大问题时需要递归解决的子问题较少，从而降低递归调用的次数，有助于提高算法的效率。</p><h3 id="2-2-Bottom-Up-Variation"><a href="#2-2-Bottom-Up-Variation" class="headerlink" title="2.2 Bottom-Up Variation"></a><span class="label label-warning">2.2 Bottom-Up Variation</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isMatch</span>(<span class="hljs-params">self, text: <span class="hljs-built_in">str</span>, pattern: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        tlen, plen = <span class="hljs-built_in">len</span>(text), <span class="hljs-built_in">len</span>(pattern)<br>        dp = [[<span class="hljs-literal">False</span>] * (plen + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(tlen + <span class="hljs-number">1</span>)]<br><br>        <span class="hljs-comment"># means &#x27;&#x27; match &#x27;&#x27;</span><br>        dp[tlen][plen] = <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">for</span> pi <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(plen - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> ti <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(tlen, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                first_match = ti &lt; tlen <span class="hljs-keyword">and</span> pattern[pi] <span class="hljs-keyword">in</span> &#123;text[ti], <span class="hljs-string">&#x27;.&#x27;</span>&#125;<br><br>                <span class="hljs-keyword">if</span> pi + <span class="hljs-number">1</span> &lt; plen <span class="hljs-keyword">and</span> pattern[pi + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>:<br>                    dp[ti][pi] = dp[ti][pi + <span class="hljs-number">2</span>] <span class="hljs-keyword">or</span> (first_match <span class="hljs-keyword">and</span> dp[ti + <span class="hljs-number">1</span>][pi])<br>                <span class="hljs-keyword">else</span>:<br>                    dp[ti][pi] = first_match <span class="hljs-keyword">and</span> dp[ti + <span class="hljs-number">1</span>][pi + <span class="hljs-number">1</span>]<br>        <br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>这段代码是一个用动态规划（Dynamic Programming）解决正则表达式匹配问题的实现。</p><p>这里的正则表达式支持 ‘.’ 表示匹配任意单个字符，’*’ 表示匹配零个或多个前面的元素。</p><p>具体解释：</p><ol><li><p><code>dp</code> 是一个二维数组，<code>dp[ti][pi]</code> 表示 <code>text[ti:]</code> 和 <code>pattern[pi:]</code> 是否匹配。</p></li><li><p><code>dp[tlen][plen] = True</code>，表示空字符串匹配空字符串。</p></li><li><p>从后往前遍历 <code>pattern</code>，对于每个字符，从后往前遍历 <code>text</code>。在这个过程中，通过递推计算 <code>dp</code> 数组。</p></li><li><p>判断当前字符是否匹配，即 <code>first_match</code> 的计算，如果 <code>pattern[pi]</code> 是 ‘.’ 或者等于 <code>text[ti]</code>，则为 <code>True</code>。</p></li><li><p>如果 <code>pattern[pi+1]</code> 是 ‘*‘，则考虑 ‘*’ 的匹配情况。这里的状态转移方程是：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[ti]</span><span class="hljs-comment">[pi]</span> = dp<span class="hljs-comment">[ti]</span><span class="hljs-comment">[pi+2]</span> or (first_match and dp<span class="hljs-comment">[ti+1]</span><span class="hljs-comment">[pi]</span>)<br></code></pre></td></tr></table></figure><p>其中，<code>dp[ti][pi+2]</code> 表示 ‘*‘ 匹配零个字符，<code>first_match and dp[ti+1][pi]</code> 表示 ‘*’ 匹配一个或多个字符。</p></li><li><p>如果 <code>pattern[pi+1]</code> 不是 ‘*’，则考虑正常字符匹配情况，即：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[ti]</span><span class="hljs-comment">[pi]</span> = first_match and dp<span class="hljs-comment">[ti+1]</span><span class="hljs-comment">[pi+1]</span><br></code></pre></td></tr></table></figure></li><li><p>最终返回 <code>dp[0][0]</code>，表示整个 <code>text</code> 和 <code>pattern</code> 是否匹配。</p></li></ol><p>这种动态规划的方法避免了递归中的重复计算，提高了算法的效率。</p><p>以 <code>text = &#39;aba&#39;</code> , <code>pattern = &#39;a*.ac*&#39;</code> 为例，观察上述代码的执行过程：</p><p>首先对 <code>dp</code> 数组初始化：</p><table><thead><tr><th align="center"></th><th align="center">a</th><th align="center">*</th><th align="center">.</th><th align="center">a</th><th align="center">c</th><th align="center">*</th><th align="center">‘’</th></tr></thead><tbody><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">False</td></tr><tr><td align="center">b</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">False</td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">False</td></tr><tr><td align="center">‘’</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">True</td></tr></tbody></table><p>当 <code>pattern</code> 为空串时，若 <code>text</code> 为空串，则匹配，否则不匹配。</p><p>外循环从右到左一次处理一列，内循环从下到上一次处理一个数组元素，并根据当前 <code>pattern</code> 字符的不同做出不同的处理。</p><p>处理倒数第二列 ‘*’：</p><table><thead><tr><th align="center"></th><th align="center">a</th><th align="center">*</th><th align="center">.</th><th align="center">a</th><th align="center">c</th><th align="center">*</th><th align="center">‘’</th></tr></thead><tbody><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">b</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">‘’</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">F</td><td align="center">True</td></tr></tbody></table><p>处理倒数第三列 ‘c’：</p><table><thead><tr><th align="center"></th><th align="center">a</th><th align="center">*</th><th align="center">.</th><th align="center">a</th><th align="center">c</th><th align="center">*</th><th align="center">‘’</th></tr></thead><tbody><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">F</td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">b</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">F</td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">F</td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">‘’</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">T</td><td align="center">F</td><td align="center">True</td></tr></tbody></table><p>处理倒数第四列 ‘a’：</p><table><thead><tr><th align="center"></th><th align="center">a</th><th align="center">*</th><th align="center">.</th><th align="center">a</th><th align="center">c</th><th align="center">*</th><th align="center">‘’</th></tr></thead><tbody><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">F</td><td align="center">F</td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">b</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">F</td><td align="center">F</td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">T</td><td align="center">F</td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">‘’</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">F</td><td align="center">T</td><td align="center">F</td><td align="center">True</td></tr></tbody></table><p>最终数组如下：</p><table><thead><tr><th align="center"></th><th align="center">a</th><th align="center">*</th><th align="center">.</th><th align="center">a</th><th align="center">c</th><th align="center">*</th><th align="center">‘’</th></tr></thead><tbody><tr><td align="center">a</td><td align="center">T</td><td align="center">F</td><td align="center">F</td><td align="center">F</td><td align="center">F</td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">b</td><td align="center">T</td><td align="center">F</td><td align="center">T</td><td align="center">F</td><td align="center">F</td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">a</td><td align="center">F</td><td align="center">F</td><td align="center">F</td><td align="center">T</td><td align="center">F</td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">‘’</td><td align="center">F</td><td align="center">F</td><td align="center">F</td><td align="center">F</td><td align="center">T</td><td align="center">F</td><td align="center">True</td></tr></tbody></table><h2 id="3-引用"><a href="#3-引用" class="headerlink" title="3 引用"></a><span class="label label-danger">3 引用</span></h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://leetcode.cn/problems/regular-expression-matching/description/">LeetCode 10. 正则表达式匹配</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Dynamic Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>Dynamic Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串匹配之 KMP 算法</title>
    <link href="/2024/02/05/kmp/"/>
    <url>/2024/02/05/kmp/</url>
    
    <content type="html"><![CDATA[<h2 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="1 问题描述[1]"></a><span class="label label-primary">1 问题描述<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[LeetCode 28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)">[1]</span></a></sup></span></h2><p>给你两个字符串 <span class="label label-danger">text</span> 和 <span class="label label-primary">pattern</span> ，请你在 <span class="label label-danger">text</span> 字符串中找出 <span class="label label-primary">pattern</span> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <span class="label label-primary">pattern</span> 不是 <span class="label label-danger">text</span> 的一部分，则返回  -1 。</p><p>其中 <code>1 &lt;= pattern.length, text.length &lt;= 10^4</code> 。</p><h2 id="2-Solution-Brute-Force-Search"><a href="#2-Solution-Brute-Force-Search" class="headerlink" title="2 Solution: Brute Force Search"></a><span class="label label-success">2 Solution: Brute Force Search</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">brute_force_search</span>(<span class="hljs-params">text, pattern</span>):<br>    text_len = <span class="hljs-built_in">len</span>(text)<br>    pattern_len = <span class="hljs-built_in">len</span>(pattern)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(text_len - pattern_len + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">match</span> = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(pattern_len):<br>            <span class="hljs-keyword">if</span> text[i + j] != pattern[j]:<br>                <span class="hljs-keyword">match</span> = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">break</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">match</span>:<br>            <span class="hljs-keyword">return</span> i<br><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>该朴素算法（brute-force）字符串搜索的时间复杂度为 <code>O((n - m + 1) * m)</code> ，其中 <code>n</code> 是文本的长度，<code>m</code> 是 <span class="label label-primary">pattern</span> 的长度。</p><p>具体分析如下：</p><ol><li>外层循环从 <code>i = 0</code> 到 <code>i = n - m</code> ，总共 <code>(n - m + 1)</code> 次迭代。</li><li>对于外层循环的每次迭代，内层循环运行 <code>m</code> 次，其中m是 <span class="label label-primary">pattern</span> 的长度。</li><li>在内层循环中，对于 <span class="label label-primary">pattern</span> 的每个字符，执行了常数时间的比较。</li></ol><p>因此，总体时间复杂度为 <code>O((n - m + 1) * m)</code> ，其中 <code>(n - m + 1)</code> 表示文本中 <span class="label label-primary">pattern</span> 可能开始的位置数量，<code>m</code> 是 <span class="label label-primary">pattern</span> 的长度。</p><p>该算法的空间复杂度为 <code>O(1)</code> ，因为它使用了常数额外空间，与输入大小无关。</p><h2 id="3-Solution-KMP-Algorithm"><a href="#3-Solution-KMP-Algorithm" class="headerlink" title="3 Solution: KMP Algorithm"></a><span class="label label-warning">3 Solution: KMP Algorithm</span></h2><h3 id="3-1-Basic-idea"><a href="#3-1-Basic-idea" class="headerlink" title="3.1 Basic idea"></a><span class="label label-warning">3.1 Basic idea</span></h3><p>当匹配过程中发生 Mismatch 时</p><img src="/2024/02/05/kmp/mismatch.png" class=""><p>Brute Force Search 算法:</p><ul><li><span class="label label-danger">text</span> 匹配位置回退到下一个起始匹配位置</li><li><span class="label label-primary">pattern</span> 匹配位置回退到0</li></ul><img src="/2024/02/05/kmp/bfsback.png" class=""><p> KMP 算法: </p><ul><li><span class="label label-danger">text</span> 的匹配位置永远不会回退</li><li><span class="label label-primary">pattern</span> 的匹配位置会根据当前 Mismatch 位置的最长严格公共前后缀（LPS）信息回退</li></ul><img src="/2024/02/05/kmp/kmpback.png" class=""><p>因此在搜索前，需要预先计算出 <span class="label label-primary">pattern</span> 每个位置处的 LPS 信息，即在各个位置 Mismatch 时，<span class="label label-primary">pattern</span> 匹配位置需要回退到哪里。</p><h3 id="3-2-LPS-具体解释"><a href="#3-2-LPS-具体解释" class="headerlink" title="3.2 LPS 具体解释"></a><span class="label label-warning">3.2 LPS 具体解释</span></h3><p>在 KMP 算法中，LPS 代表 “Longest Proper Prefix which is also Suffix” ，即最长的既是 Proper（严格）前缀又是后缀的字符串。</p><p>具体解释如下：</p><ol><li><strong>Prefix</strong>: 一个字符串的前缀是指从字符串的开头开始的任何子串，包括空字符串和字符串本身。对于字符串 <code>&quot;ABC&quot;</code> ，它的前缀字符串包括： <code>&quot;&quot;</code> , <code>&quot;A&quot;</code> , <code>&quot;AB&quot;</code> , <code>&quot;ABC&quot;</code>。</li><li><strong>Proper Prefix</strong>: 是指一个字符串的严格前缀，即不包括字符串本身的前缀。对于字符串 <code>&quot;ABC&quot;</code> ，其proper prefix包括： <code>&quot;&quot;</code> , <code>&quot;A&quot;</code> , <code>&quot;AB&quot;</code>。</li><li><strong>Suffix</strong>: 一个字符串的后缀是指从字符串的结尾开始的任何子串，包括空字符串和字符串本身。对于字符串 <code>&quot;ABC&quot;</code> ，它的后缀包括：<code>&quot;&quot;</code> , <code>&quot;C&quot;</code> , <code>&quot;BC&quot;</code> ,  <code>&quot;ABC&quot;</code>。</li></ol><p>因此，字符串 <code>&quot;ABAB&quot;</code> 的 LPS 是 <code>&quot;AB&quot;</code>，字符串 <code>&quot;ABC&quot;</code> 的 LPS 是 <code>&quot;&quot;</code>。</p><h3 id="3-3-算法预处理：为-pattern-构建-LPS-数组"><a href="#3-3-算法预处理：为-pattern-构建-LPS-数组" class="headerlink" title="3.3 算法预处理：为 pattern 构建 LPS 数组"></a><span class="label label-warning">3.3 算法预处理：为 pattern 构建 LPS 数组</span></h3><p>LPS 数组是一个用于加速 KMP 算法的辅助数组，用于在匹配失败时跳过尽可能多的字符，从而提高字符串匹配的效率。</p><p>例如，对于 <span class="label label-primary">pattern</span> <code>&quot;abazabaxtabazabazp&quot;</code> , LPS 数组是 [0, 0, 1, 0, 1, 2, 3, 0, 0, 1, 2, 3, 4, 5, 6, 7, 4, 0]。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-symbol">LPS</span>[i] 含义：字符串 pattern[:i+<span class="hljs-number">1</span>] 的 <span class="hljs-symbol">LPS</span> 的长度<br><br><span class="hljs-string">&quot;a&quot;</span>: 公共严格前后缀为<span class="hljs-string">&quot;&quot;</span> 或者说 无公共严格前后缀, <span class="hljs-symbol">LPS</span>[<span class="hljs-number">0</span>] 永远等于<span class="hljs-number">0</span><br><br><span class="hljs-string">&quot;ab&quot;</span>: 无公共严格前后缀，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br><br><span class="hljs-string">&quot;aba&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;a&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span><br><br><span class="hljs-string">&quot;abaz&quot;</span>: 无公共严格前后缀，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span><br><br><span class="hljs-string">&quot;abaza&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;a&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">4</span>] = <span class="hljs-number">1</span><br><br><span class="hljs-string">&quot;abazab&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;ab&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">5</span>] = <span class="hljs-number">2</span><br><br><span class="hljs-string">&quot;abazaba&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;aba&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">6</span>] = <span class="hljs-number">3</span><br><br><span class="hljs-string">&quot;abazabax&quot;</span>: 无公共严格前后缀，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">7</span>] = <span class="hljs-number">0</span><br><br><span class="hljs-string">&quot;abazabaxt&quot;</span>: 无公共严格前后缀，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">8</span>] = <span class="hljs-number">0</span><br><br><span class="hljs-string">&quot;abazabaxta&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;a&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">9</span>] = <span class="hljs-number">1</span><br><br><span class="hljs-string">&quot;abazabaxtab&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;ab&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">10</span>] = <span class="hljs-number">2</span><br><br><span class="hljs-string">&quot;abazabaxtaba&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;aba&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">11</span>] = <span class="hljs-number">3</span><br><br><span class="hljs-string">&quot;abazabaxtabaz&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;abaz&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">12</span>] = <span class="hljs-number">4</span><br><br><span class="hljs-string">&quot;abazabaxtabaza&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;abaza&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">13</span>] = <span class="hljs-number">5</span><br><br><span class="hljs-string">&quot;abazabaxtabazab&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;abazab&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">14</span>] = <span class="hljs-number">6</span><br><br><span class="hljs-string">&quot;abazabaxtabazaba&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;abazaba&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">15</span>] = <span class="hljs-number">7</span><br><br><span class="hljs-string">&quot;abazabaxtabazabaz&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;abazabaz&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">16</span>] = <span class="hljs-number">4</span><br><br><span class="hljs-string">&quot;abazabaxtabazabazp&quot;</span>: 无公共严格前后缀，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">17</span>] = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>如何使用代码来生成 LPS 数组呢？</strong></p><p>假设我们已经计算出了 <code>&quot;abazabaxtabazab&quot;</code> 的 LPS 为 <code>&quot;abazab&quot;</code> </p><img src="/2024/02/05/kmp/lps01.png" class=""><p>如何计算 <code>&quot;abazabaxtabazaba&quot;</code> 的 LPS 呢？</p><img src="/2024/02/05/kmp/lps10.png" class=""><p>显然 <span class="label label-primary">pattern[6] &#x3D;&#x3D; pattern[15]</span></p><img src="/2024/02/05/kmp/lps1.png" class=""><p> <code>&quot;abazabaxtabazaba&quot;</code> 的 LPS 为 <code>&quot;abazaba&quot;</code></p><img src="/2024/02/05/kmp/lps2.png" class=""><p>接下来计算 <code>&quot;abazabaxtabazabaz&quot;</code> 的 LPS</p><img src="/2024/02/05/kmp/lps3.png" class=""><p>此刻 <span class="label label-primary">pattern[7] !&#x3D; pattern[16]</span></p><img src="/2024/02/05/kmp/lps4.png" class=""><p>我们需要找到一个更短的前缀进行尝试</p><img src="/2024/02/05/kmp/lps5.png" class=""><p>此刻 <span class="label label-primary">pattern[4] &#x3D;&#x3D; pattern[16]</span></p><img src="/2024/02/05/kmp/lps6.png" class=""><p> <code>&quot;abazabaxtabazabaz&quot;</code> 的 LPS 为 <code>&quot;abaz&quot;</code></p><img src="/2024/02/05/kmp/lps7.png" class=""><p>最后计算 <code>&quot;abazabaxtabazabazp&quot;</code> 的 LPS</p><img src="/2024/02/05/kmp/lps8.png" class=""><p>发现没有更短前缀可以尝试(或者说这里在匹配 <code>&quot;&quot;</code> 前缀)，并且 <span class="label label-primary">pattern[0] !&#x3D; pattern[17]</span> ，所以 LPS &#x3D; 0</p><img src="/2024/02/05/kmp/lps9.png" class=""><p>当没有前缀可以匹配(或者说在匹配 <code>&quot;&quot;</code> 前缀)时的两种情况</p><ul><li>当前匹配字符与 <span class="label label-primary">pattern[0]</span> 相等，LPS &#x3D; 1</li><li>当前匹配字符与 <span class="label label-primary">pattern[0]</span> 不相等，LPS &#x3D; 0</li></ul><img src="/2024/02/05/kmp/lps_end.png" class=""><p>实现逻辑总结：</p><ol><li><p>我们在最开始初始化一个前缀长度变量 <code>prefix = 0</code> ，表示只有单个字符的字符串没有 LPS 。</p></li><li><p>然后从 <code>i = 1</code> 开始由短到长逐渐计算每个字符串的 LPS</p><p><strong>匹配成功时的增长：</strong> 如果字符匹配成功（<span class="label label-primary">pattern[i] &#x3D;&#x3D; pattern[prefix]</span>），则继续增加前缀的长度（<code>prefix += 1</code>）。</p><p><strong>匹配失败时的回退：</strong> 当发生匹配失败时（<span class="label label-primary">pattern[i] !&#x3D; pattern[prefix]</span>），通过回退的方式，找到一个更短的前缀进行尝试。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_lps_array</span>(<span class="hljs-params">pattern: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]:<br>    lps = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(pattern)<br><br>    <span class="hljs-comment"># 初始前缀长度为0</span><br>    prefix = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 从第二个字符开始遍历pattern</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(pattern)):<br>        <span class="hljs-comment"># 匹配失败时，回退前缀长度，条件 prefix &gt; 0 保证了可回退 </span><br>        <span class="hljs-keyword">while</span> prefix &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> pattern[i] != pattern[prefix]:<br>            prefix = lps[prefix - <span class="hljs-number">1</span>]<br><br>        <span class="hljs-comment"># 匹配成功，增加前缀长度</span><br>        <span class="hljs-keyword">if</span> pattern[i] == pattern[prefix]:<br>            prefix += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-comment"># 匹配失败时 lps[i] = 0</span><br>        lps[i] = prefix<br>    <br>    <span class="hljs-keyword">return</span> lps<br></code></pre></td></tr></table></figure><p><strong>时间复杂度分析</strong></p><p class="note note-info"> 初始时我觉得代码包括两层循环结构，所以时间复杂度是 O(m^2) ，其中 m 是 <span class="label label-primary">pattern</span> 的长度，但是网上都说是 O(m) 让我很难理解。</p><p>在每一轮 for 循环中，<code>prefix</code> 在匹配成功时增加1，而在匹配失败时可能经过多次回退。然而，总的回退次数受限于总的成功匹配次数，<code>prefix</code> 至多增加到 <code>m</code>，所以总的回退次数至多也是 <code>m</code>。因此，整体的时间复杂度为 <code>O(m)</code>。</p><p class="note note-success">可以这样想，我有一张初始余额为0 (prefix = 0)的银行卡，每次匹配成功，就在卡里存1块钱(prefix += 1)，每次匹配失败时，就花一次钱(prefix = lps[prefix - 1])，但是花钱的额度不能超过余额(同时是正整数元）。<br/><br/>在整个构建 lps[] 的过程中，我至多存 m 块钱，因此我至多消费 m 块钱，所以消费次数(匹配失败回退次数)一定不超过 m。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 回退虽然在两层循环中进行，但是整个过程至多回退m次</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(pattern)):<br>    <span class="hljs-keyword">while</span> prefix &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> pattern[i] != pattern[prefix]:<br>        prefix = lps[prefix - <span class="hljs-number">1</span>]<br>    <br>    <span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><p>打破了我对嵌套的两层循环，一定是平方时间复杂度的认知。下面的这个例子，时间复杂度是 <code>O(nlogn)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 外层循环n次，内层循环log(n)次</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j *= <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-comment">// 做一些操作</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-搜索部分"><a href="#3-4-搜索部分" class="headerlink" title="3.4 搜索部分"></a><span class="label label-warning">3.4 搜索部分</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">kmp_search</span>(<span class="hljs-params">text: <span class="hljs-built_in">str</span>, pattern: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    lps = compute_lps_array(pattern)<br>    text_index = pattern_index = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">while</span> text_index &lt; <span class="hljs-built_in">len</span>(text):<br>        <span class="hljs-comment"># 如果当前字符匹配，则继续比较下一个字符</span><br>        <span class="hljs-keyword">if</span> text[text_index] == pattern[pattern_index]:<br>            text_index += <span class="hljs-number">1</span><br>            pattern_index += <span class="hljs-number">1</span><br>            <br>            <span class="hljs-comment"># 如果pattern的所有字符都匹配，则返回匹配的起始索引</span><br>            <span class="hljs-keyword">if</span> pattern_index == <span class="hljs-built_in">len</span>(pattern):<br>                <span class="hljs-keyword">return</span> text_index - <span class="hljs-built_in">len</span>(pattern)<br>        <span class="hljs-comment"># 如果当前字符不匹配，并且pattern的索引不是0，则回退到上一个匹配字符的位置</span><br>        <span class="hljs-keyword">elif</span> pattern_index != <span class="hljs-number">0</span>:<br>            pattern_index = lps[pattern_index - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果当前字符不匹配，并且pattern的索引已经是0，继续检查text的下一个字符</span><br>            text_index += <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>搜索部分的时间复杂度为 <code>O(n)</code>，其中 <code>n</code> 为 <span class="label label-danger">text</span> 的长度。</p><p class="note note-danger">分析同上，<span class="label label-primary">pattern_index</span> 在匹配成功时增加1，在匹配失败时回退。然而，总的回退次数受限于总的成功匹配次数，<span class="label label-primary">pattern_index</span> 至多增加 n 次，所以总的回退次数至多也是 n。因此，整体的时间复杂度为 O(n)。</p><p>所以 KMP 算法的总体时间复杂度为 <code>O(m + n)</code>。</p><h2 id="4-效率对比"><a href="#4-效率对比" class="headerlink" title="4 效率对比"></a><span class="label label-danger">4 效率对比</span></h2><p>起因是我想知道自己实现的 KMP 算法与 Python 自带的 str.find() 方法有多大的差距。</p><p>测试代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">brute_force_search</span>(<span class="hljs-params">text, pattern</span>):<br>    text_len = <span class="hljs-built_in">len</span>(text)<br>    pattern_len = <span class="hljs-built_in">len</span>(pattern)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(text_len - pattern_len + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">match</span> = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(pattern_len):<br>            <span class="hljs-keyword">if</span> text[i + j] != pattern[j]:<br>                <span class="hljs-keyword">match</span> = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">match</span>:<br>            <span class="hljs-keyword">return</span> i<br><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_lps_array</span>(<span class="hljs-params">pattern: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]:<br>    lps = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(pattern)<br><br>    <span class="hljs-comment"># 初始前缀长度为0</span><br>    prefix = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 从第二个字符开始遍历pattern</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(pattern)):<br>        <span class="hljs-comment"># 匹配失败时，回退前缀长度，条件 prefix &gt; 0 保证了可回退 </span><br>        <span class="hljs-keyword">while</span> prefix &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> pattern[i] != pattern[prefix]:<br>            prefix = lps[prefix - <span class="hljs-number">1</span>]<br><br>        <span class="hljs-comment"># 匹配成功，增加前缀长度（包括了 prefix = 0 且 匹配成功的情况）</span><br>        <span class="hljs-keyword">if</span> pattern[i] == pattern[prefix]:<br>            prefix += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-comment"># 匹配失败时 lps[i] = 0</span><br>        lps[i] = prefix<br>    <br>    <span class="hljs-keyword">return</span> lps<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">kmp_search</span>(<span class="hljs-params">text: <span class="hljs-built_in">str</span>, pattern: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    lps = compute_lps_array(pattern)<br>    text_index = pattern_index = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">while</span> text_index &lt; <span class="hljs-built_in">len</span>(text):<br>        <span class="hljs-comment"># 如果当前字符匹配，则继续比较下一个字符</span><br>        <span class="hljs-keyword">if</span> text[text_index] == pattern[pattern_index]:<br>            text_index += <span class="hljs-number">1</span><br>            pattern_index += <span class="hljs-number">1</span><br>            <br>            <span class="hljs-comment"># 如果pattern的所有字符都匹配，则返回匹配的起始索引</span><br>            <span class="hljs-keyword">if</span> pattern_index == <span class="hljs-built_in">len</span>(pattern):<br>                <span class="hljs-keyword">return</span> text_index - <span class="hljs-built_in">len</span>(pattern)<br>        <span class="hljs-comment"># 如果当前字符不匹配，并且pattern的索引不是0，则回退到上一个匹配字符的位置</span><br>        <span class="hljs-keyword">elif</span> pattern_index != <span class="hljs-number">0</span>:<br>            pattern_index = lps[pattern_index - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果当前字符不匹配，并且pattern的索引已经是0，继续检查text的下一个字符</span><br>            text_index += <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br><span class="hljs-comment"># 创建文本和模式</span><br>text = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">1000000</span> + <span class="hljs-string">&#x27;b&#x27;</span><br>pattern = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">100</span> + <span class="hljs-string">&#x27;b&#x27;</span><br><br><span class="hljs-comment"># 测试暴力搜索算法</span><br>start = time.time()<br>res = brute_force_search(text, pattern)<br>end = time.time()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Brute Force Search:&#x27;</span>, (end - start) * <span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;ms, res =&#x27;</span>, res)<br><br><span class="hljs-comment"># 测试KMP算法</span><br>start = time.time()<br>res = kmp_search(text, pattern)<br>end = time.time()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;KMP Search:&#x27;</span>, (end - start) * <span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;ms, res =&#x27;</span>, res)<br><br><span class="hljs-comment"># Python find()</span><br>start = time.time()<br>res = text.find(pattern)<br>end = time.time()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Python find:&#x27;</span>, (end - start) * <span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;ms, res =&#x27;</span>, res)<br><br><span class="hljs-comment"># output</span><br><span class="hljs-comment"># Brute Force Search: 10057.930946350098 ms, res = 999900</span><br><span class="hljs-comment"># KMP Search: 449.2683410644531 ms, res = 999900</span><br><span class="hljs-comment"># Python find: 1.7478466033935547 ms, res = 999900</span><br></code></pre></td></tr></table></figure><p>最开始很震惊，为什么 Python str.find() 方法运行效率比我的 KMP 快这么多？</p><p class="note note-primary">Python 自带的 find 方法是用 C 语言实现的，在底层经过高度优化，因此在大多数情况下会比纯 Python 代码更快。<br/><br/>而 KMP 算法虽然在某些情况下比朴素的字符串匹配算法更高效，但是它的实现依然是纯 Python 代码。尽管 KMP 算法的时间复杂度为 O(n + m)，其中 n 为文本长度，m 为模式串长度，但是在实际情况下，算法中涉及了大量的数组操作和条件判断，这些操作在 Python 中相比 C 语言而言速度会慢一些。因此，对于较大规模的数据，Python  自带的 find 方法通常会更快，因为它是直接调用底层 C 代码执行查找操作。<br/><br/>总的来说，Python 的内置方法通常会经过高度优化，运行速度更快，但在一些特定情况下，使用自定义的算法可能会更适合。</p><p>下面使用 C 来实现 KMP 算法看一下运行效率。</p><h2 id="5-C语言版本KMP"><a href="#5-C语言版本KMP" class="headerlink" title="5 C语言版本KMP"></a><span class="label label-info">5 C语言版本KMP</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">kmp_search</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* text, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* pattern)</span> &#123;<br>    <span class="hljs-type">int</span> tlen = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (text[tlen] != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        tlen++;<br>    &#125;<br><br>    <span class="hljs-type">int</span> plen = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (pattern[plen] != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        plen++;<br>    &#125;<br><br>    <span class="hljs-type">int</span>* lps = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(plen * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (lps == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 内存分配失败</span><br>    &#125;<br><br>    <span class="hljs-comment">// 构建 lps 数组</span><br>    <span class="hljs-type">int</span> prefix = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; plen; i++) &#123;<br>        <span class="hljs-keyword">while</span> (prefix &gt; <span class="hljs-number">0</span> &amp;&amp; pattern[i] != pattern[prefix]) &#123;<br>            prefix = lps[prefix - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (pattern[i] == pattern[prefix]) &#123;<br>            prefix++;<br>        &#125;<br><br>        lps[i] = prefix;<br>    &#125;<br><br>    <span class="hljs-comment">// 匹配过程</span><br>    <span class="hljs-type">int</span> pi = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ti = <span class="hljs-number">0</span>; ti &lt; tlen; ti++) &#123;<br>        <span class="hljs-keyword">while</span> (pi &gt; <span class="hljs-number">0</span> &amp;&amp; text[ti] != pattern[pi]) &#123;<br>            pi = lps[pi - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (text[ti] == pattern[pi]) &#123;<br>            <span class="hljs-keyword">if</span> (pi == plen - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">free</span>(lps);<br>                <span class="hljs-keyword">return</span> ti - plen + <span class="hljs-number">1</span>;<br>            &#125;<br>            pi++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">free</span>(lps);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义一个函数，用于生成由n个c字符组成的字符串</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">repeat_char</span><span class="hljs-params">(<span class="hljs-type">char</span> c, <span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-comment">// 分配n+1个字节的内存空间，用于存储字符串和结束符&#x27;\0&#x27;</span><br>    <span class="hljs-type">char</span> *s = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 判断内存分配是否成功</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;内存分配失败\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 使用memset函数，将s的前n个字节都填充为c字符</span><br>    <span class="hljs-built_in">memset</span>(s, c, n);<br>    <span class="hljs-comment">// 在最后一个字节添加结束符&#x27;\0&#x27;</span><br>    s[n] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-comment">// 返回生成的字符串</span><br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span>* text = repeat_char(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1000001</span>);<br>    text[<span class="hljs-number">1000000</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>    <span class="hljs-type">char</span>* pattern = repeat_char(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">101</span>);<br>    pattern[<span class="hljs-number">100</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br><br>    <span class="hljs-type">clock_t</span> start_time = clock();<br>    <span class="hljs-type">int</span> result = kmp_search(text, pattern);<br>    <span class="hljs-type">clock_t</span> end_time = clock();<br>    <span class="hljs-type">double</span> execution_time = ((<span class="hljs-type">double</span>)(end_time - start_time)) / CLOCKS_PER_SEC * <span class="hljs-number">1000.0</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Execution Time: %f ms\n&quot;</span>, execution_time);<br><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Pattern found at index %d\n&quot;</span>, result);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Pattern not found in the text\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">// output</span><br><span class="hljs-comment">// Execution Time: 8.270000 ms</span><br><span class="hljs-comment">// Pattern found at index 999900</span><br></code></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">text</span> = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">1000000</span> + <span class="hljs-string">&#x27;b&#x27;</span><br><span class="hljs-attr">pattern</span> = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">100</span> + <span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><p>用时对比：</p><table><thead><tr><th>Algorithm</th><th>Time (ms)</th></tr></thead><tbody><tr><td>Brute Force Search (Python)</td><td>10057.931</td></tr><tr><td>KMP Search (Python)</td><td>449.268</td></tr><tr><td>KMP Search (C)</td><td>8.270</td></tr><tr><td>Python find</td><td>1.748</td></tr></tbody></table><p>可以看出 Python 和 C 的执行效率存在巨大差距。</p><h2 id="6-引用"><a href="#6-引用" class="headerlink" title="6 引用"></a><span class="label label-default">6 引用</span></h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">LeetCode 28. 找出字符串中第一个匹配项的下标</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>String</category>
      
      <category>String Matching</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解 CAS</title>
    <link href="/2022/08/19/cas/"/>
    <url>/2022/08/19/cas/</url>
    
    <content type="html"><![CDATA[<h3 id="Java层面探究"><a href="#Java层面探究" class="headerlink" title="Java层面探究"></a><span class="label label-primary">Java层面探究</span></h3><p>Java中的原子类<code>Atomic</code>底层的实现原理是CAS，本文就让我们一起来深入探究CAS。<br>下面是<code>AtomicInteger</code>的测试代码 ，执行完毕后会发现原子类实例<code>ai</code>最终是精确的10000，而普通变量<code>bi</code>的值是一个小于10000的不固定的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hw.review2022.concurrent;<br> <br><span class="hljs-keyword">import</span> org.junit.Test;<br> <br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCAS</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 被多个线程访问的变量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ai</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">bi</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对ai和bi执行1000次自增</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-comment">//任务id</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br> <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Task</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>            <span class="hljs-built_in">this</span>.id = i;<br>        &#125;<br> <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>               <span class="hljs-keyword">try</span>&#123;<br>                   <span class="hljs-keyword">if</span>(i % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>) &#123;<br>                       System.out.println(<span class="hljs-string">&quot;Thread name : &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;, Task id : &quot;</span> + id + <span class="hljs-string">&quot;, loop : &quot;</span> + i);<br>                   &#125;<br>                   Thread.sleep(<span class="hljs-number">2</span>);<br>                   ai.addAndGet(<span class="hljs-number">1</span>);<br>                   bi++;<br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                   e.printStackTrace();<br>               &#125;<br>           &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 创建含有3个线程的线程池</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 在线程池中执行10个任务</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(i));<br>        &#125;<br> <br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 等待线程池中的任务执行完毕后才去打印ai和bi的值</span><br><span class="hljs-comment">         */</span><br>        executor.shutdown();<br>        executor.awaitTermination(<span class="hljs-number">60</span>, TimeUnit.SECONDS);<br>        System.out.println(<span class="hljs-string">&quot;ai is right : &quot;</span> + ai);<br>        System.out.println(<span class="hljs-string">&quot;bi is wrong : &quot;</span> + bi);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码的核心是 <code>AtomicInteger.addAndGet</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> valueOffset;<br>    <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Atomically adds the given value to the current value.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> delta the value to add</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the updated value</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addAndGet</span><span class="hljs-params">(<span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-built_in">this</span>, valueOffset, delta) + delta;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们看一下<code>AtomicInteger</code>类实例对象的内存布局</p><img src="/2022/08/19/cas/layout.png" class=""><p><code>this</code>指向了对象的起始地址，通过<code>this + valueOffset(=12)</code>我们就可以获得<code>value</code>字段的内存地址（即C&#x2F;C++中的指向<code>value</code>的指针），进而读写该<code>value</code>值。</p><p>然后我们接着看<code>Unsafe.getAndAddInt</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//                             原子实例ai  valueOffset  delta(增量)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">int</span> var4)</span> &#123;<br>    <span class="hljs-type">int</span> var5;<br>    <span class="hljs-keyword">do</span> &#123;<br>        var5 = <span class="hljs-built_in">this</span>.getIntVolatile(var1, var2); <span class="hljs-comment">// var5: oldValue</span><br>    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4)); <span class="hljs-comment">// var5 + var4: updateValue</span><br> <br>    <span class="hljs-keyword">return</span> var5;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>var5</code>这个变量是通过<code>ai</code>的起始地址 + <code>valueOffset</code>偏移值获取到<code>value</code>的内存地址，进而获取到的<code>value</code>的值，我们把这个值称为<span class="label label-primary">oldValue</span></p><p><code>var5+var4</code>就是我们期望更新的值，我们把它叫做<span class="label label-info">updateValue</span></p><p>接下来发现<code>Unsafe.compareAndSwapInt</code>是一个 native 方法(就是在Java虚拟机中用 C&#x2F;C++ 实现的方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapInt</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">int</span> var4, <span class="hljs-type">int</span> var5)</span>;<br></code></pre></td></tr></table></figure><h3 id="C-x2F-C-层面探究"><a href="#C-x2F-C-层面探究" class="headerlink" title="C&#x2F;C++层面探究"></a><span class="label label-success">C&#x2F;C++层面探究</span></h3><p>现在Java语言层面我们已经分析完了，完全看不到CAS具体是怎么实现的，接下来我们继续去探究JDK源码<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Github OpenJDK8源码](https://github.com/AdoptOpenJDK/openjdk-jdk8u)">[1]</span></a></sup></p><p><code>Unsafe.compareAndSwapInt</code>的源码所在目录为<code>hotspot/src/share/vm/prims/unsafe.cpp</code></p><p>这个方法的前两个参数不用去了解（JNI是Java调用C的方式），后四个参数和<code>Unsafe.compareAndSwapInt</code>方法的一一对应。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">UNSAFE_ENTRY</span>(jboolean, <span class="hljs-built_in">Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))<br>  <span class="hljs-built_in">UnsafeWrapper</span>(<span class="hljs-string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);<br>  oop p = JNIHandles::<span class="hljs-built_in">resolve</span>(obj);<br>  jint* addr = (jint *) <span class="hljs-built_in">index_oop_from_field_offset_long</span>(p, offset);<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * x代表了期望更新的值updateValue</span><br><span class="hljs-comment">   * addr代表了value这个字段的内存地址</span><br><span class="hljs-comment">   * e代表了oldValue</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">return</span> (jint)(Atomic::<span class="hljs-built_in">cmpxchg</span>(x, addr, e)) == e;<br>UNSAFE_END<br></code></pre></td></tr></table></figure><p>继续往下分析来到了最核心的部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">inline</span> jint     <span class="hljs-title function_">Atomic::cmpxchg</span>    <span class="hljs-params">(jint     exchange_value, <span class="hljs-keyword">volatile</span> jint*     dest, jint     compare_value)</span> &#123;<br>  <span class="hljs-type">int</span> mp = os::is_MP(); <span class="hljs-comment">// MP means multiprocessor，多处理器系统需要给cmpxchg指令加上lock前缀</span><br>  __asm__ <span class="hljs-title function_">volatile</span> <span class="hljs-params">(LOCK_IF_MP(%<span class="hljs-number">4</span>) <span class="hljs-string">&quot;cmpxchgl %1,(%3)&quot;</span></span><br><span class="hljs-params">                    : <span class="hljs-string">&quot;=a&quot;</span> (exchange_value)</span><br><span class="hljs-params">                    : <span class="hljs-string">&quot;r&quot;</span> (exchange_value), <span class="hljs-string">&quot;a&quot;</span> (compare_value), <span class="hljs-string">&quot;r&quot;</span> (dest), <span class="hljs-string">&quot;r&quot;</span> (mp)</span><br><span class="hljs-params">                    : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>)</span>;<br>  <span class="hljs-keyword">return</span> exchange_value;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>cmpxchgl</code>是一个汇编指令（最后一个字符<code>l</code>代表了<code>cmpxchg</code>指令的参数类型为<code>jint</code>，对于<code>jlong</code>类型最后一个字符是<code>q</code>，不同操作系统可能会不同），所以我们需要去理解<code>cmpxchg</code>这条汇编指令。</p><h3 id="汇编层面探究"><a href="#汇编层面探究" class="headerlink" title="汇编层面探究"></a><span class="label label-danger">汇编层面探究</span></h3><p>下面给出我在C中实现的CAS来帮助大家理解CAS和<code>cmpxchg</code>指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pthread.h&quot;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> oldValue, <span class="hljs-type">int</span>* addr, <span class="hljs-type">int</span> updateValue)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">atomic_add</span><span class="hljs-params">(<span class="hljs-type">int</span>* addr, <span class="hljs-type">int</span> delta)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">task</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">atomic_task</span><span class="hljs-params">()</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 被多个线程访问的共享变量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-type">atomic_count</span> = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br> <br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试代码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">pthread_t</span> tid, tid2, tid3, tid4, tid5, tid6;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建了6个子线程，tid为子线程id，task和atomic_task是子线程的任务函数</span><br><span class="hljs-comment">     */</span><br>    pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, (<span class="hljs-type">void</span> *) task, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid2, <span class="hljs-literal">NULL</span>, (<span class="hljs-type">void</span> *) task, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid3, <span class="hljs-literal">NULL</span>, (<span class="hljs-type">void</span> *) task, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid4, <span class="hljs-literal">NULL</span>, (<span class="hljs-type">void</span> *) <span class="hljs-type">atomic_task</span>, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid5, <span class="hljs-literal">NULL</span>, (<span class="hljs-type">void</span> *) <span class="hljs-type">atomic_task</span>, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid6, <span class="hljs-literal">NULL</span>, (<span class="hljs-type">void</span> *) <span class="hljs-type">atomic_task</span>, <span class="hljs-literal">NULL</span>);<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 主线程等待6个子线程执行完才会往下执行printf</span><br><span class="hljs-comment">     */</span><br>    pthread_join(tid, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid2, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid3, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid4, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid5, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid6, <span class="hljs-literal">NULL</span>);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;count is %d\n&quot;</span>, count); <span class="hljs-comment">//预期最后的结果小于900000</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;atomic_count is %d\n&quot;</span>, <span class="hljs-type">atomic_count</span>); <span class="hljs-comment">//预期最后的结果精确等于900000</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>   <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param oldValue 最开始获取到的value值</span><br><span class="hljs-comment"> * @param addr 多线程访问的变量的地址</span><br><span class="hljs-comment"> * @param updateValue 期望更新的新值</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> oldValue, <span class="hljs-type">int</span>* addr, <span class="hljs-type">int</span> updateValue)</span> &#123;<br>    <span class="hljs-type">int</span> resValue;<br>    __asm__ __volatile__ (<span class="hljs-string">&quot;lock\n\t&quot;</span><br>                          <span class="hljs-string">&quot;cmpxchgl %2, (%3)&quot;</span><br>                          : <span class="hljs-string">&quot;=a&quot;</span>(resValue)<br>                          : <span class="hljs-string">&quot;a&quot;</span>(oldValue), <span class="hljs-string">&quot;r&quot;</span>(updateValue), <span class="hljs-string">&quot;r&quot;</span>(addr)<br>                          : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>);<br>    <span class="hljs-keyword">return</span> resValue;<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param addr 多线程访问变量的地址</span><br><span class="hljs-comment"> * @param delta 这个变量想要增加的值</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">atomic_add</span><span class="hljs-params">(<span class="hljs-type">int</span>* addr, <span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-type">int</span> oldValue;<br>    <span class="hljs-keyword">do</span> &#123;<br>        oldValue = *addr;<br>    &#125; <span class="hljs-keyword">while</span> ( cmp(oldValue, addr, oldValue + delta) != oldValue );<br>&#125;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">atomic_task</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">300000</span>; i++) &#123;<br>        <span class="hljs-type">atomic_add</span>(&amp;<span class="hljs-type">atomic_count</span>, <span class="hljs-number">1</span>);<br>        usleep(<span class="hljs-number">60</span>);<br>    &#125;<br>&#125;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">task</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">300000</span>; i++) &#123;<br>        count += <span class="hljs-number">1</span>;<br>        usleep(<span class="hljs-number">60</span>); <span class="hljs-comment">//0.06ms</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重点讲解一下<code>cmp</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> oldValue, <span class="hljs-type">int</span>* addr, <span class="hljs-type">int</span> updateValue)</span> &#123;<br>    <span class="hljs-type">int</span> resValue;<br>    __asm__ __volatile__ (<span class="hljs-string">&quot;lock\n\t&quot;</span>   <span class="hljs-comment">//保证原子性</span><br>                          <span class="hljs-string">&quot;cmpxchgl %2, (%3)&quot;</span> <span class="hljs-comment">//核心指令</span><br>                          : <span class="hljs-string">&quot;=a&quot;</span>(resValue) <span class="hljs-comment">//输出列表</span><br>                          : <span class="hljs-string">&quot;a&quot;</span>(oldValue), <span class="hljs-string">&quot;r&quot;</span>(updateValue), <span class="hljs-string">&quot;r&quot;</span>(addr) <span class="hljs-comment">//输入列表</span><br>                          : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>); <span class="hljs-comment">//表明这条内联汇编会更改内存值和flag寄存器</span><br>    <span class="hljs-keyword">return</span> resValue;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实也就是我自己实现的JDK中的<code>Atomic::cmpxchg</code>函数，只不过更容易看懂一些。</p><p><span class="label label-primary">oldValue</span>就是我们先前获取到的<code>value</code>值，<code>addr</code>就是<code>value</code>字段的内存地址，在<code>cmpxchg</code>指令中会用到这个地址，<span class="label label-info">updateValue</span>就是我们期望更新的<code>value</code>值(<span class="label label-primary">oldValue</span>+增量<code>delta</code>)</p><p>以下关于内联汇编的知识大家可以去参考GCC-Inline-Assembly-HOWTO<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[GCC-Inline-Assembly-HOWTO](http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html)">[2]</span></a></sup></p><p>输入列表中：</p><p><code>&quot;a&quot;(oldValue)</code>：a代表EAX寄存器，意思是将变量<span class="label label-primary">oldValue</span>的值输入到EAX寄存器</p><p><code>&quot;r&quot;(updateValue) &quot;r&quot;(addr)</code>：意思是将变量<span class="label label-info">updateValue</span>和地址<code>addr</code>也放到寄存器中，r(register)代表一组寄存器，也就是从这一组寄存器中随便选一个存<span class="label label-info">updateValue</span>，随便选一个存<code>addr</code></p><p>输出列表中：</p><p><code>&quot;=a&quot;(resValue)</code>：表示内联汇编执行完后，将EAX寄存器的值存到<code>resValue</code>这个变量中。</p><p>我们在输出列表和输入列表中声明了许多变量，这些变量从<code>%0</code>开始依次往下标号，所以<code>%0</code>表示<code>resValue</code>，<code>%1</code>代表了<span class="label label-primary">oldValue</span>，<code>%2</code>代表了<span class="label label-info">updateValue</span>，<code>%3</code>代表了<code>addr</code>。</p><p>现在我们结合的<code>cmpxchg</code>指令的功能，来理解一下这段汇编到底在做什么。汇编语言有Intel和AT&amp;T两种语法，一般我们用的都是AT&amp;T这种，下面的讲解也是基于该语法的:</p><p class="note note-info">cmpxchg 指令有两个操作数，同时还使用了EAX 寄存器。首先，它将第二个操作数和EAX寄存器相比较，如果相同则把第一个操作数赋值给第二个操作数，否则将第一个操作数赋值给EAX 寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmpxchgl %2, (%3) <br></code></pre></td></tr></table></figure><p><code>%2</code>是第一个操作数，即<span class="label label-info">updateValue</span>，也就是无冲突的时候我们期望更新的值</p><p><code>(%3)</code>是第二个操作数，即<code>(addr)</code>，<code>()</code>表示取值操作(相当于C语言中的<code>*</code>)，因为<code>addr</code>是<code>value</code>变量的地址，所以该操作数是在取此刻<code>value</code>的值<code>curValue</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *a = <span class="hljs-number">5</span>; <span class="hljs-comment">//代表了a是一个指针，指向一个int变量，即a是该int变量的地址，*a表示取该int变量的值5</span><br></code></pre></td></tr></table></figure><p>首先将<span class="label label-primary">oldValue</span>存储到EAX寄存器中，然后用第二个操作数<code>curValue</code>和<span class="label label-primary">oldValue</span>行比较，如果相等，则说明从得到<span class="label label-primary">oldValue</span>到现在执行<code>cmpxchg</code>这条指令这段时间内，<code>value</code>没有被其他线程改写（抛开ABA问题不谈），没有发生冲突，所以我们就可以直接把我们希望更新的新值<span class="label label-info">updateValue</span>写入到<code>value</code>中，那我们再来看看<code>cmpxchg</code>这条指令干了啥，如果相同则把第一个操作数赋值给第二个操作数，也就是将<span class="label label-info">updateValue</span>赋值给<code>value</code>对象（成功更新<code>value</code>的值）。现在这条指令就执行完毕了，EAX寄存器中存储的还是<span class="label label-primary">oldValue</span>，所以最终<code>cmp</code>函数返回的也就是<span class="label label-primary">oldValue</span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">atomic_add</span><span class="hljs-params">(<span class="hljs-type">int</span>* addr, <span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-type">int</span> oldValue;<br>    <span class="hljs-keyword">do</span> &#123;<br>        oldValue = *addr;<br>    &#125; <span class="hljs-keyword">while</span> ( cmp(oldValue, addr, oldValue + delta) != oldValue );<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数也就可以返回了，对应的就是Java中的<code>Unsafe.getAndAddInt</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">int</span> var4)</span> &#123;<br>    <span class="hljs-type">int</span> var5;<br>    <span class="hljs-keyword">do</span> &#123;<br>        var5 = <span class="hljs-built_in">this</span>.getIntVolatile(var1, var2);<br>    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<br> <br>    <span class="hljs-keyword">return</span> var5;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果EAX中保存的<span class="label label-primary">oldValue</span>和我们执行<code>cmpxchg</code>指令时获取的<code>curValue</code>不同，说明<code>value</code>的值被其他线程改写了，那此刻将第一个操作数<span class="label label-info">updateValue</span>赋值给 EAX 寄存器（我们并没有更新<code>value</code>的值），所以<code>cmp</code>函数返回的值为<span class="label label-info">updateValue</span>。<code>atomic_add</code>函数中<code>cmp</code>返回的<span class="label label-info">updateValue</span>和<span class="label label-primary">oldValue</span>不同，所以要重新执行<code>do while</code>循环去自旋，直到没有冲突发生。</p><h3 id="动画展示与总结"><a href="#动画展示与总结" class="headerlink" title="动画展示与总结"></a><span class="label label-info">动画展示与总结</span></h3><p>该动画使用Python <code>manim</code>库<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Github 3b1b/manim](https://github.com/3b1b/manim)">[3]</span></a></sup>制作，<a href="https://github.com/hwollin/animation/blob/main/os/thread/concurrent/cas_animation.py">动画源码</a></p><video width="100%" controls>  <source src="cas.mp4" type="video/mp4"></video><p>最后我们再用高级语言解释一下<code>cmpxchg</code>这条汇编指令的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 被多个线程访问的value对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> value;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注意下面的逻辑是一条汇编指令完成的</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param addr value对象的内存地址</span><br><span class="hljs-comment"> * @param oldValue 执行cmpxchg指令前当前线程获取到的value对象的值</span><br><span class="hljs-comment"> * @param updateValue 期望更新的值</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">cmpxchg</span><span class="hljs-params">(<span class="hljs-type">int</span>* addr, <span class="hljs-type">int</span> oldValue, <span class="hljs-type">int</span> updateValue)</span><br>&#123;<br>    <span class="hljs-type">int</span> curValue = *addr; <span class="hljs-comment">//获取最新的value的值</span><br>    <span class="hljs-keyword">if</span> (curValue == oldValue) &#123; <span class="hljs-comment">//无冲突则更新value值为updateValue并返回oldValue</span><br>        *addr == updateValue;<br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//发生冲突，直接返回updateValue，value对象的值没有更新哦</span><br>        <span class="hljs-keyword">return</span> updateValue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a><span class="label label-warning">引用</span></h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://github.com/AdoptOpenJDK/openjdk-jdk8u">Github OpenJDK8源码</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">GCC-Inline-Assembly-HOWTO</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://github.com/3b1b/manim">Github 3b1b&#x2F;manim</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Concurrency Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Java</tag>
      
      <tag>C/C++</tag>
      
      <tag>Assembly</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
