<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2024/02/06/test/"/>
    <url>/2024/02/06/test/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 10 正则表达式匹配</title>
    <link href="/2024/02/06/LeetCode_10/"/>
    <url>/2024/02/06/LeetCode_10/</url>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>Given an input string <code>s</code> and a pattern <code>p</code>, implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code> where:</p><ul><li><code>&#39;.&#39;</code> Matches any single character.</li><li><code>&#39;*&#39;</code> Matches zero or more of the preceding element.</li></ul><p>The matching should cover the <strong>entire</strong> input string (not partial).</p><p><strong>Example 1:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">Input:</span> s = <span class="hljs-string">&quot;aa&quot;</span>, p = <span class="hljs-string">&quot;a&quot;</span><br><span class="hljs-symbol">Output:</span> <span class="hljs-literal">false</span><br><span class="hljs-symbol">Explanation:</span> <span class="hljs-string">&quot;a&quot;</span> does <span class="hljs-built_in">not</span> match the entire <span class="hljs-type">string</span> <span class="hljs-string">&quot;aa&quot;</span>.<br></code></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Input: s = <span class="hljs-string">&quot;aa&quot;</span>, p = <span class="hljs-string">&quot;a*&quot;</span><br>Output: <span class="hljs-literal">true</span><br>Explanation: <span class="hljs-string">&#x27;*&#x27;</span> means <span class="hljs-literal">zero</span> <span class="hljs-keyword">or</span> more <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> preceding <span class="hljs-keyword">element</span>, <span class="hljs-string">&#x27;a&#x27;</span>. Therefore, <span class="hljs-keyword">by</span> repeating <span class="hljs-string">&#x27;a&#x27;</span> once, <span class="hljs-keyword">it</span> becomes <span class="hljs-string">&quot;aa&quot;</span>.<br></code></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">Input:</span> s = <span class="hljs-string">&quot;ab&quot;</span>, p = <span class="hljs-string">&quot;.*&quot;</span><br><span class="hljs-symbol">Output:</span> <span class="hljs-literal">true</span><br><span class="hljs-symbol">Explanation:</span> <span class="hljs-string">&quot;.*&quot;</span> means <span class="hljs-string">&quot;zero or more (*) of any character (.)&quot;</span>.<br></code></pre></td></tr></table></figure><p><strong>出错过的用例:</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">Input:</span> s = <span class="hljs-string">&quot;abc&quot;</span>, p = <span class="hljs-string">&quot;c*abc&quot;</span><br><span class="hljs-symbol">Output:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>特殊用例:</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Input: s = <span class="hljs-string">&quot;abc&quot;</span>, p = <span class="hljs-string">&quot;a***abc&quot;</span>     <span class="hljs-keyword">a</span>***abc可以拆分成 <span class="hljs-string">&#x27;a* ** bc&#x27;</span>, 连续的两个**可以匹配<span class="hljs-string">&#x27;&#x27;</span>(<span class="hljs-literal">null</span> <span class="hljs-keyword">string</span>)<br>Output: <span class="hljs-literal">true</span><br>从这个用例，在写程序的时，意识到**是可以在模式串中存在的就可以了。<br><br>Input: s = <span class="hljs-string">&quot;abc&quot;</span>, p = <span class="hljs-string">&quot;a**abc&quot;</span> <span class="hljs-keyword">a</span>**abc 没有意义，第二个 * 没有前面的元素可以匹配<br>Output: <span class="hljs-literal">false</span> <br></code></pre></td></tr></table></figure><p> <strong>Constraints:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 20</code></li><li><code>1 &lt;= p.length &lt;= 20</code></li><li><code>s</code> contains only lowercase English letters.</li><li><code>p</code> contains only lowercase English letters, <code>&#39;.&#39;</code>, and <code>&#39;*&#39;</code>.</li><li>It is guaranteed for each appearance of the character <code>&#39;*&#39;</code>, there will be a previous valid character to match.</li></ul><hr><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h3><h4 id="1-Top-Down-Variation"><a href="#1-Top-Down-Variation" class="headerlink" title="1 Top-Down Variation"></a>1 Top-Down Variation</h4><p><strong>1.1 LeetCode Solution</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isMatch</span>(<span class="hljs-params">self, text: <span class="hljs-built_in">str</span>, pattern: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        memo = &#123;&#125;<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">dp</span>(<span class="hljs-params">ti, pi</span>):<br>            <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            Function: Check if text[ti:] matches pattern[pi:]</span><br><span class="hljs-string">            Parameters:</span><br><span class="hljs-string">                ti: int, text index</span><br><span class="hljs-string">                pi: int, pattern index</span><br><span class="hljs-string">            Returns:</span><br><span class="hljs-string">                bool: True if match, False otherwise</span><br><span class="hljs-string">            &quot;&quot;&quot;</span><br>            <span class="hljs-keyword">if</span> (ti, pi) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> memo:<br>                <span class="hljs-comment"># base case</span><br>                <span class="hljs-keyword">if</span> pi == <span class="hljs-built_in">len</span>(pattern):<br>                    ans = ti == <span class="hljs-built_in">len</span>(text)<br>                <span class="hljs-keyword">else</span>:<br>                    <span class="hljs-comment"># first_match: text和pattern的第一个字符匹配吗？</span><br>                    first_match = ti &lt; <span class="hljs-built_in">len</span>(text) <span class="hljs-keyword">and</span> pattern[pi] <span class="hljs-keyword">in</span> &#123;text[ti], <span class="hljs-string">&#x27;.&#x27;</span>&#125;<br><br>                    <span class="hljs-comment"># case: &#x27;*&#x27;</span><br>                    <span class="hljs-keyword">if</span> pi + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(pattern) <span class="hljs-keyword">and</span> pattern[pi + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>:<br>                        ans = dp(ti, pi + <span class="hljs-number">2</span>) <span class="hljs-keyword">or</span> (first_match <span class="hljs-keyword">and</span> dp(ti + <span class="hljs-number">1</span>, pi))<br>                    <span class="hljs-comment"># case: &#x27;.&#x27; and ordinary char</span><br>                    <span class="hljs-keyword">else</span>:<br>                        ans = first_match <span class="hljs-keyword">and</span> dp(ti + <span class="hljs-number">1</span>, pi + <span class="hljs-number">1</span>)<br><br>                memo[(ti, pi)] = ans<br><br>            <span class="hljs-keyword">return</span> memo[(ti, pi)]<br><br>        <span class="hljs-keyword">return</span> dp(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>这段代码是一个实现正则表达式匹配的算法，使用了动态规划的思想。主要是通过递归函数<code>dp</code>来判断给定的<code>text</code>和<code>pattern</code>是否匹配。</p><p>下面是对代码的详细解释：</p><ol><li><p><code>memo</code>是一个字典，用于存储已经计算过的子问题的结果，避免重复计算，提高算法效率。</p></li><li><p><code>dp</code>函数是递归函数，用于检查<code>text[ti:]</code>是否匹配<code>pattern[pi:]</code>。</p></li><li><p>在函数内部，首先检查<code>(ti, pi)</code>是否已经在<code>memo</code>中，如果在，则直接返回之前计算的结果。</p></li><li><p>如果<code>(ti, pi)</code>不在<code>memo</code>中，首先判断基本情况，即如果<code>pi</code>等于<code>pattern</code>的长度，那么结果为<code>ti</code>是否等于<code>text</code>的长度。也就是说，如果<code>pattern</code>已经遍历完，那么<code>text</code>也必须遍历完才算匹配。</p><p>因为在非基本情况中，<code>ti</code> 和 <code>pi</code> 会变大，所以最终会遇到 <code>text[len(text):]</code> <code>pattern[len(pattern):]</code>即被匹配的<code>text</code> <code>pattern</code> 为 <code>&#39;&#39;</code>的情况。</p><table><thead><tr><th align="center"></th><th align="center">pattern &#x3D; ‘’</th><th align="center">pattern !&#x3D; ‘’</th></tr></thead><tbody><tr><td align="center">text &#x3D; ‘’</td><td align="center">匹配</td><td align="center">需要判断</td></tr><tr><td align="center">text !&#x3D; ‘’</td><td align="center">不匹配</td><td align="center">需要判断</td></tr></tbody></table><ul><li><p>当 <code>text = &#39;&#39;, pattern= &#39;c*c*&#39;</code> 时，匹配。</p></li><li><p>当 <code>text = &#39;&#39;, pattern= &#39;a&#39;</code> 时，不匹配，所以需要判断。</p></li></ul></li><li><p>如果<code>pi</code>不等于<code>pattern</code>的长度，接下来判断第一个字符是否匹配。定义<code>first_match</code>表示<code>text</code>和<code>pattern</code>的第一个字符是否匹配，它取决于当前字符和<code>&#39;.&#39;</code>是否相等。</p></li><li><p>如果下一个字符是<code>&#39;*&#39;</code>，则有两种情况：</p><ul><li>不使用<code>&#39;*&#39;</code>，即<code>dp(ti, pi + 2)</code>，表示<code>&#39;*&#39;</code>前面的字符在<code>text</code>中出现0次。</li><li>使用<code>&#39;*&#39;</code>，即<code>(first_match and dp(ti + 1, pi))</code>，表示<code>&#39;*&#39;</code>前面的字符在<code>text</code>中出现至少1次，递归检查剩下的部分。</li></ul></li><li><p>如果下一个字符不是<code>&#39;*&#39;</code>，则简单地匹配当前字符，即<code>first_match and dp(ti + 1, pi + 1)</code>。</p></li><li><p>将计算结果存入<code>memo</code>，然后返回结果。</p></li><li><p>最终调用<code>dp(0, 0)</code>，从<code>text</code>和<code>pattern</code>的开头开始检查匹配关系。</p></li></ol><p>总体来说，这是一个使用动态规划思想的递归算法，通过存储子问题的解避免了重复计算，提高了算法效率。</p><p><strong>1.2 My Solution</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isMatch</span>(<span class="hljs-params">self, text: <span class="hljs-built_in">str</span>, pattern: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        memo = &#123;&#125;<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">is_char_match</span>(<span class="hljs-params">text_char, pattern_char</span>):<br>            <span class="hljs-keyword">return</span> pattern_char == <span class="hljs-string">&#x27;.&#x27;</span> <span class="hljs-keyword">or</span> text_char == pattern_char<br><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">recursive_match</span>(<span class="hljs-params">text_index, pattern_index</span>):<br>            <span class="hljs-keyword">if</span> (text_index, pattern_index) <span class="hljs-keyword">in</span> memo:<br>                <span class="hljs-keyword">return</span> memo[(text_index, pattern_index)]<br><br>            <span class="hljs-comment"># base case</span><br>            <span class="hljs-keyword">if</span> pattern_index == <span class="hljs-built_in">len</span>(pattern):<br>                result =  text_index == <span class="hljs-built_in">len</span>(text)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># case: &#x27;*&#x27;</span><br>                <span class="hljs-keyword">if</span> pattern_index + <span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(pattern) <span class="hljs-keyword">and</span> pattern[pattern_index + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>:<br>                    i, previous_char = <span class="hljs-number">0</span>, pattern[pattern_index]<br>                    <span class="hljs-comment"># 匹配0次*之前的字符</span><br>                    result = recursive_match(text_index, pattern_index + <span class="hljs-number">2</span>)<br><br>                    <span class="hljs-comment"># 匹配多次*之前的字符</span><br>                    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> result <span class="hljs-keyword">and</span> text_index + i &lt; <span class="hljs-built_in">len</span>(text) <span class="hljs-keyword">and</span> is_char_match(text[text_index + i], previous_char):<br>                        result = recursive_match(text_index + i + <span class="hljs-number">1</span>, pattern_index + <span class="hljs-number">2</span>)<br>                        i += <span class="hljs-number">1</span><br>                <span class="hljs-comment"># case: &#x27;.&#x27; &#x27;c&#x27;</span><br>                <span class="hljs-keyword">else</span>:<br>                    result = text_index &lt; <span class="hljs-built_in">len</span>(text) <span class="hljs-keyword">and</span> is_char_match(text[text_index], pattern[pattern_index]) <span class="hljs-keyword">and</span> recursive_match(text_index + <span class="hljs-number">1</span>, pattern_index + <span class="hljs-number">1</span>)<br><br>            memo[(text_index, pattern_index)] = result<br>            <span class="hljs-keyword">return</span> result<br><br>        <span class="hljs-keyword">return</span> recursive_match(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>这段代码与上面代码的不同在于当遇到 <code>&#39;*&#39;</code> 时的处理，假设在计算 <code>dp(ti, pi)</code> 时，<code>pattern[pi + 2]</code> 是 <code>&#39;*&#39;</code> , <code>LeetCode</code> 的处理逻辑是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dp(ti, pi) = dp(ti, pi + <span class="hljs-number">2</span>) <span class="hljs-keyword">or</span> (first_match <span class="hljs-keyword">and</span> dp(ti + <span class="hljs-number">1</span>, pi))<br></code></pre></td></tr></table></figure><p>一个大问题被拆分成了两个子问题。</p><p><code>My Solution</code> 的处理逻辑是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 匹配0次*之前的字符</span><br>result = recursive_match(text_index, pattern_index + <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 匹配多次*之前的字符</span><br><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> result <span class="hljs-keyword">and</span> text_index + i &lt; <span class="hljs-built_in">len</span>(text) <span class="hljs-keyword">and</span> is_char_match(text[text_index + i], previous_char):<br>    result = recursive_match(text_index + i + <span class="hljs-number">1</span>, pattern_index + <span class="hljs-number">2</span>)<br>    i += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>采用了一个 <code>while</code> 循环来迭代匹配多次 <code>&#39;*&#39;</code> 前的字符，一个大问题在极端情况下至多被拆分成了 <code>len(text)</code> 个子问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dp(ti, pi) = dp(ti, pi + <span class="hljs-number">2</span>) <span class="hljs-keyword">or</span> dp(ti + <span class="hljs-number">1</span>, pi + <span class="hljs-number">2</span>) ..... <span class="hljs-keyword">or</span> dp(<span class="hljs-built_in">len</span>(text) + <span class="hljs-number">1</span>, pi + <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p><strong>1.3 LeetCode vs Mine - 代码效率比较</strong></p><p>为了测试两段代码在极端情况下的效率差异，我们使用以下测试数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">text = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">500</span><br>pattern = <span class="hljs-string">&quot;a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*c&quot;</span><br><br>My Solution:<br>dp() 调用次数: <span class="hljs-number">2</span>,<span class="hljs-number">515</span>,<span class="hljs-number">522</span> | memo 命中次数: <span class="hljs-number">2</span>,<span class="hljs-number">505</span>,<span class="hljs-number">000</span> | memo 大小: <span class="hljs-number">10</span>,<span class="hljs-number">522</span><br>时间: <span class="hljs-number">2.51</span> 秒<br><br>LeetCode Solution:<br>dp() 调用次数: <span class="hljs-number">21</span>,023 | memo 命中次数: <span class="hljs-number">10</span>,001 | memo 大小: <span class="hljs-number">11</span>,022<br>时间: <span class="hljs-number">0.02</span> 秒<br></code></pre></td></tr></table></figure><ul><li><p><strong><code>memo size</code> 比较：</strong> 两者几乎相同，表明解决的子问题数量相近。假设 <code>text</code> 长度为 <code>M</code>，<code>pattern</code> 长度为 <code>N</code>，则计算 <code>dp(0, 0)</code> 需要解决的子问题规模约为 <code>M * N</code>。</p></li><li><p><strong><code>dp()</code> 调用次数比较：</strong> “My Solution” 中的 <code>dp()</code> 调用次数是 “LeetCode Solution” 的125倍（2,515,522 对比 21,023）。这说明 “My Solution” 中存在大量重复的子问题。</p></li><li><p><strong><code>time</code> 比较：</strong> “My Solution” 的执行时间也是 “LeetCode Solution” 的125倍。</p></li></ul><p>因此， “My Solution” 的问题主要出在 <code>dp()</code> 被调用的重复子问题数量过多。</p><p>在分析子问题调用次数问题之前，我们来看一下两个程序的执行结果：</p><p><strong>My Solution</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">text = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">5</span><br>pattern = <span class="hljs-string">&quot;a*a*a*a*a*c&quot;</span><br><br><span class="hljs-comment"># dp[ti][pi] 表示子问题 dp(ti, pi) 的调用次数，执行 dp(0, 0) 后数组如下：</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 子问题的解决顺序</span><br>[<span class="hljs-number">31</span>, <span class="hljs-number">0</span>, <span class="hljs-number">25</span>, <span class="hljs-number">0</span>, <span class="hljs-number">19</span>, <span class="hljs-number">0</span>, <span class="hljs-number">13</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">26</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">14</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">27</span>, <span class="hljs-number">0</span>, <span class="hljs-number">21</span>, <span class="hljs-number">0</span>, <span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">28</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0</span>, <span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">29</span>, <span class="hljs-number">0</span>, <span class="hljs-number">23</span>, <span class="hljs-number">0</span>, <span class="hljs-number">17</span>, <span class="hljs-number">0</span>, <span class="hljs-number">11</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">30</span>, <span class="hljs-number">0</span>, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>, <span class="hljs-number">18</span>, <span class="hljs-number">0</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>一个大问题最多依赖 <code>M</code> 个子问题，一个子问题最多被 <code>M</code> 个大问题调用。</p><table><thead><tr><th align="center"></th><th align="center">a</th><th align="center">*</th><th align="center">a</th><th align="center">*</th><th align="center">a</th><th align="center">*</th><th align="center">a</th><th align="center">*</th><th>a</th><th align="center">*</th><th align="center">c</th><th>‘’</th></tr></thead><tbody><tr><td align="center">a</td><td align="center">dp(0, 0)</td><td align="center"></td><td align="center">X</td><td align="center"></td><td align="center">x</td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center">Y</td><td align="center"></td><td align="center">x</td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center">Z</td><td align="center"></td><td align="center">x</td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center">P</td><td align="center"></td><td align="center">x</td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center">R</td><td align="center"></td><td align="center">x</td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center">‘’</td><td align="center"></td><td align="center"></td><td align="center">S</td><td align="center"></td><td align="center">x,y,z,p,r,s</td><td align="center"></td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td></td></tr></tbody></table><p>在上面的表格中，大问题 <code>X dp(0, 2)</code> 依赖 <code>M</code> 个子问题 <code>x</code> ，子问题 <code>x dp(5, 4)</code>  最多被 <code>M</code> 个大问题 <code>X Y Z P R S</code> 依赖，子问题的规模是 <code>M * N</code> ，每个子问题最多被调用 <code>M</code> 次，所以最终时间复杂度是 <code>O(M^2 * N)</code>。</p><p><strong>LeetCode Solution</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">text = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">5</span><br>pattern = <span class="hljs-string">&quot;a*a*a*a*a*c&quot;</span><br><br><span class="hljs-comment"># dp[ti][pi] 表示子问题 dp(ti, pi) 的调用次数，执行 dp(0, 0) 后数组如下：</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 子问题的解决顺序</span><br>[<span class="hljs-number">36</span>, <span class="hljs-number">0</span>, <span class="hljs-number">30</span>, <span class="hljs-number">0</span>, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>, <span class="hljs-number">18</span>, <span class="hljs-number">0</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">35</span>, <span class="hljs-number">0</span>, <span class="hljs-number">29</span>, <span class="hljs-number">0</span>, <span class="hljs-number">23</span>, <span class="hljs-number">0</span>, <span class="hljs-number">17</span>, <span class="hljs-number">0</span>, <span class="hljs-number">11</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">34</span>, <span class="hljs-number">0</span>, <span class="hljs-number">28</span>, <span class="hljs-number">0</span>, <span class="hljs-number">22</span>, <span class="hljs-number">0</span>, <span class="hljs-number">16</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">33</span>, <span class="hljs-number">0</span>, <span class="hljs-number">27</span>, <span class="hljs-number">0</span>, <span class="hljs-number">21</span>, <span class="hljs-number">0</span>, <span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">32</span>, <span class="hljs-number">0</span>, <span class="hljs-number">26</span>, <span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">14</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>]<br>[<span class="hljs-number">31</span>, <span class="hljs-number">0</span>, <span class="hljs-number">25</span>, <span class="hljs-number">0</span>, <span class="hljs-number">19</span>, <span class="hljs-number">0</span>, <span class="hljs-number">13</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>一个大问题至多依赖两个子问题，一个子问题至多被两个大问题调用。</p><table><thead><tr><th align="center"></th><th align="center">a</th><th align="center">*</th><th align="center">a</th><th align="center">*</th><th align="center">a</th><th align="center">*</th><th align="center">a</th><th align="center">*</th><th align="center">a</th><th align="center">*</th><th align="center">c</th><th align="center">‘’</th></tr></thead><tbody><tr><td align="center">a</td><td align="center">dp(0,0)</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">Y</td><td align="center">y</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">X: dp(1, 4)</td><td align="center"></td><td align="center">x,y: dp(1, 6)</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">x: dp(2, 4)</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">‘’</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>在上面的表格中，大问题 <code>X dp(1, 4)</code> 依赖两个子问题 <code>x dp(2, 4)</code> <code>x dp(1, 6)</code> ，子问题 <code>dp(1, 6)</code>  至多被两个大问题 <code>X Y</code> 依赖，子问题的规模是 <code>M * N</code> ，每个子问题最多被调用两次，所以最终时间复杂度是 <code>O(M * N)</code>。</p><p><strong>结论：</strong> 在递归算法中，大问题对子问题的依赖数量越少越好。较少的依赖意味着解决大问题时需要递归解决的子问题较少，从而降低递归调用的次数，有助于提高算法的效率。</p><h4 id="2-Bottom-Up-Variation"><a href="#2-Bottom-Up-Variation" class="headerlink" title="2 Bottom-Up Variation"></a>2 Bottom-Up Variation</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">isMatch</span>(<span class="hljs-params">self, text: <span class="hljs-built_in">str</span>, pattern: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">bool</span>:<br>        tlen, plen = <span class="hljs-built_in">len</span>(text), <span class="hljs-built_in">len</span>(pattern)<br>        dp = [[<span class="hljs-literal">False</span>] * (plen + <span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(tlen + <span class="hljs-number">1</span>)]<br><br>        <span class="hljs-comment"># means &#x27;&#x27; match &#x27;&#x27;</span><br>        dp[tlen][plen] = <span class="hljs-literal">True</span><br><br>        <span class="hljs-keyword">for</span> pi <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(plen - <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">for</span> ti <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(tlen, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>                first_match = ti &lt; tlen <span class="hljs-keyword">and</span> pattern[pi] <span class="hljs-keyword">in</span> &#123;text[ti], <span class="hljs-string">&#x27;.&#x27;</span>&#125;<br><br>                <span class="hljs-keyword">if</span> pi + <span class="hljs-number">1</span> &lt; plen <span class="hljs-keyword">and</span> pattern[pi + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>:<br>                    dp[ti][pi] = dp[ti][pi + <span class="hljs-number">2</span>] <span class="hljs-keyword">or</span> (first_match <span class="hljs-keyword">and</span> dp[ti + <span class="hljs-number">1</span>][pi])<br>                <span class="hljs-keyword">else</span>:<br>                    dp[ti][pi] = first_match <span class="hljs-keyword">and</span> dp[ti + <span class="hljs-number">1</span>][pi + <span class="hljs-number">1</span>]<br>        <br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>这段代码是一个用动态规划（Dynamic Programming）解决正则表达式匹配问题的实现。</p><p>这里的正则表达式支持 ‘.’ 表示匹配任意单个字符，’*’ 表示匹配零个或多个前面的元素。</p><p>具体解释：</p><ol><li><p><code>dp</code> 是一个二维数组，<code>dp[ti][pi]</code> 表示 <code>text[ti:]</code> 和 <code>pattern[pi:]</code> 是否匹配。</p></li><li><p><code>dp[tlen][plen] = True</code>，表示空字符串匹配空字符串。</p></li><li><p>从后往前遍历 <code>pattern</code>，对于每个字符，从后往前遍历 <code>text</code>。在这个过程中，通过递推计算 <code>dp</code> 数组。</p></li><li><p>判断当前字符是否匹配，即 <code>first_match</code> 的计算，如果 <code>pattern[pi]</code> 是 ‘.’ 或者等于 <code>text[ti]</code>，则为 <code>True</code>。</p></li><li><p>如果 <code>pattern[pi+1]</code> 是 ‘*‘，则考虑 ‘*’ 的匹配情况。这里的状态转移方程是：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[ti]</span><span class="hljs-comment">[pi]</span> = dp<span class="hljs-comment">[ti]</span><span class="hljs-comment">[pi+2]</span> or (first_match and dp<span class="hljs-comment">[ti+1]</span><span class="hljs-comment">[pi]</span>)<br></code></pre></td></tr></table></figure><p>其中，<code>dp[ti][pi+2]</code> 表示 ‘*‘ 匹配零个字符，<code>first_match and dp[ti+1][pi]</code> 表示 ‘*’ 匹配一个或多个字符。</p></li><li><p>如果 <code>pattern[pi+1]</code> 不是 ‘*’，则考虑正常字符匹配情况，即：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">dp<span class="hljs-comment">[ti]</span><span class="hljs-comment">[pi]</span> = first_match and dp<span class="hljs-comment">[ti+1]</span><span class="hljs-comment">[pi+1]</span><br></code></pre></td></tr></table></figure></li><li><p>最终返回 <code>dp[0][0]</code>，表示整个 <code>text</code> 和 <code>pattern</code> 是否匹配。</p></li></ol><p>这种动态规划的方法避免了递归中的重复计算，提高了算法的效率。</p><p>以 <code>text = &#39;aba&#39;</code> , <code>pattern = &#39;a*.ac*&#39;</code> 为例，观察上述代码的执行过程：</p><p>首先对 <code>dp</code> 数组初始化：</p><table><thead><tr><th align="center"></th><th align="center">a</th><th align="center">*</th><th align="center">.</th><th align="center">a</th><th align="center">c</th><th align="center">*</th><th align="center">‘’</th></tr></thead><tbody><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">False</td></tr><tr><td align="center">b</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">False</td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">False</td></tr><tr><td align="center">‘’</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">True</td></tr></tbody></table><p>当 <code>pattern</code> 为空串时，若 <code>text</code> 为空串，则匹配，否则不匹配。</p><p>外循环从右到左一次处理一列，内循环从下到上一次处理一个数组元素，并根据当前 <code>pattern</code> 字符的不同做出不同的处理。</p><p>处理倒数第二列 ‘*’：</p><table><thead><tr><th align="center"></th><th align="center">a</th><th align="center">*</th><th align="center">.</th><th align="center">a</th><th align="center">c</th><th align="center">*</th><th align="center">‘’</th></tr></thead><tbody><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">b</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">‘’</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">F</td><td align="center">True</td></tr></tbody></table><p>处理倒数第三列 ‘c’：</p><table><thead><tr><th align="center"></th><th align="center">a</th><th align="center">*</th><th align="center">.</th><th align="center">a</th><th align="center">c</th><th align="center">*</th><th align="center">‘’</th></tr></thead><tbody><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">F</td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">b</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">F</td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">F</td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">‘’</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">T</td><td align="center">F</td><td align="center">True</td></tr></tbody></table><p>处理倒数第四列 ‘a’：</p><table><thead><tr><th align="center"></th><th align="center">a</th><th align="center">*</th><th align="center">.</th><th align="center">a</th><th align="center">c</th><th align="center">*</th><th align="center">‘’</th></tr></thead><tbody><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">F</td><td align="center">F</td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">b</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">F</td><td align="center">F</td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">T</td><td align="center">F</td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">‘’</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">F</td><td align="center">T</td><td align="center">F</td><td align="center">True</td></tr></tbody></table><p>最终数组如下：</p><table><thead><tr><th align="center"></th><th align="center">a</th><th align="center">*</th><th align="center">.</th><th align="center">a</th><th align="center">c</th><th align="center">*</th><th align="center">‘’</th></tr></thead><tbody><tr><td align="center">a</td><td align="center">T</td><td align="center">F</td><td align="center">F</td><td align="center">F</td><td align="center">F</td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">b</td><td align="center">T</td><td align="center">F</td><td align="center">T</td><td align="center">F</td><td align="center">F</td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">a</td><td align="center">F</td><td align="center">F</td><td align="center">F</td><td align="center">T</td><td align="center">F</td><td align="center">F</td><td align="center">False</td></tr><tr><td align="center">‘’</td><td align="center">F</td><td align="center">F</td><td align="center">F</td><td align="center">F</td><td align="center">T</td><td align="center">F</td><td align="center">True</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>Dynamic Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Algorithm</tag>
      
      <tag>Dynamic Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串匹配之KMP算法</title>
    <link href="/2024/02/05/kmp/"/>
    <url>/2024/02/05/kmp/</url>
    
    <content type="html"><![CDATA[<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1 问题描述"></a><span class="label label-primary">1 问题描述</span></h2><p>给你两个字符串 <span class="label label-danger">text</span> 和 <span class="label label-primary">pattern</span> ，请你在 <span class="label label-danger">text</span> 字符串中找出 <span class="label label-primary">pattern</span> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <span class="label label-primary">pattern</span> 不是 <span class="label label-danger">text</span> 的一部分，则返回  -1 。</p><p>其中 <code>1 &lt;= pattern.length, text.length &lt;= 10^4</code> 。</p><h2 id="2-Brute-Force-Search"><a href="#2-Brute-Force-Search" class="headerlink" title="2 Brute Force Search"></a><span class="label label-success">2 Brute Force Search</span></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">brute_force_search</span>(<span class="hljs-params">text, pattern</span>):<br>    text_len = <span class="hljs-built_in">len</span>(text)<br>    pattern_len = <span class="hljs-built_in">len</span>(pattern)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(text_len - pattern_len + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">match</span> = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(pattern_len):<br>            <span class="hljs-keyword">if</span> text[i + j] != pattern[j]:<br>                <span class="hljs-keyword">match</span> = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">break</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">match</span>:<br>            <span class="hljs-keyword">return</span> i<br><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>该朴素算法（brute-force）字符串搜索的时间复杂度为 <code>O((n - m + 1) * m)</code> ，其中 <code>n</code> 是文本的长度，<code>m</code> 是 <span class="label label-primary">pattern</span> 的长度。</p><p>具体分析如下：</p><ol><li>外层循环从 <code>i = 0</code> 到 <code>i = n - m</code> ，总共 <code>(n - m + 1)</code> 次迭代。</li><li>对于外层循环的每次迭代，内层循环运行 <code>m</code> 次，其中m是 <span class="label label-primary">pattern</span> 的长度。</li><li>在内层循环中，对于 <span class="label label-primary">pattern</span> 的每个字符，执行了常数时间的比较。</li></ol><p>因此，总体时间复杂度为 <code>O((n - m + 1) * m)</code> ，其中 <code>(n - m + 1)</code> 表示文本中 <span class="label label-primary">pattern</span> 可能开始的位置数量，<code>m</code> 是 <span class="label label-primary">pattern</span> 的长度。</p><p>该算法的空间复杂度为 <code>O(1)</code> ，因为它使用了常数额外空间，与输入大小无关。</p><h2 id="3-KMP-Algorithm"><a href="#3-KMP-Algorithm" class="headerlink" title="3 KMP Algorithm"></a><span class="label label-warning">3 KMP Algorithm</span></h2><h3 id="3-1-Basic-idea"><a href="#3-1-Basic-idea" class="headerlink" title="3.1 Basic idea"></a><span class="label label-warning">3.1 Basic idea</span></h3><p>当匹配过程中发生 Mismatch 时</p><img src="/2024/02/05/kmp/mismatch.png" class=""><p>Brute Force Search 算法:</p><ul><li><span class="label label-danger">text</span> 匹配位置回退到下一个起始匹配位置</li><li><span class="label label-primary">pattern</span> 匹配位置回退到0</li></ul><img src="/2024/02/05/kmp/bfsback.png" class=""><p> KMP 算法: </p><ul><li><span class="label label-danger">text</span> 的匹配位置永远不会回退</li><li><span class="label label-primary">pattern</span> 的匹配位置会根据当前 Mismatch 位置的最长严格公共前后缀（LPS）信息回退</li></ul><img src="/2024/02/05/kmp/kmpback.png" class=""><p>因此在搜索前，需要预先计算出 <span class="label label-primary">pattern</span> 每个位置处的 LPS 信息，即在各个位置 Mismatch 时，<span class="label label-primary">pattern</span> 匹配位置需要回退到哪里。</p><h3 id="3-2-LPS-具体解释"><a href="#3-2-LPS-具体解释" class="headerlink" title="3.2 LPS 具体解释"></a><span class="label label-warning">3.2 LPS 具体解释</span></h3><p>在 KMP 算法中，LPS 代表 “Longest Proper Prefix which is also Suffix” ，即最长的既是 Proper（严格）前缀又是后缀的字符串。</p><p>具体解释如下：</p><ol><li><strong>Prefix</strong>: 一个字符串的前缀是指从字符串的开头开始的任何子串，包括空字符串和字符串本身。对于字符串 <code>&quot;ABC&quot;</code> ，它的前缀字符串包括： <code>&quot;&quot;</code> , <code>&quot;A&quot;</code> , <code>&quot;AB&quot;</code> , <code>&quot;ABC&quot;</code>。</li><li><strong>Proper Prefix</strong>: 是指一个字符串的严格前缀，即不包括字符串本身的前缀。对于字符串 <code>&quot;ABC&quot;</code> ，其proper prefix包括： <code>&quot;&quot;</code> , <code>&quot;A&quot;</code> , <code>&quot;AB&quot;</code>。</li><li><strong>Suffix</strong>: 一个字符串的后缀是指从字符串的结尾开始的任何子串，包括空字符串和字符串本身。对于字符串 <code>&quot;ABC&quot;</code> ，它的后缀包括：<code>&quot;&quot;</code> , <code>&quot;C&quot;</code> , <code>&quot;BC&quot;</code> ,  <code>&quot;ABC&quot;</code>。</li></ol><p>因此，字符串 <code>&quot;ABAB&quot;</code> 的 LPS 是 <code>&quot;AB&quot;</code>，字符串 <code>&quot;ABC&quot;</code> 的 LPS 是 <code>&quot;&quot;</code>。</p><h3 id="3-3-算法预处理：为-pattern-构建-LPS-数组"><a href="#3-3-算法预处理：为-pattern-构建-LPS-数组" class="headerlink" title="3.3 算法预处理：为 pattern 构建 LPS 数组"></a><span class="label label-warning">3.3 算法预处理：为 pattern 构建 LPS 数组</span></h3><p>LPS 数组是一个用于加速 KMP 算法的辅助数组，用于在匹配失败时跳过尽可能多的字符，从而提高字符串匹配的效率。</p><p>例如，对于 <span class="label label-primary">pattern</span> <code>&quot;abazabaxtabazabazp&quot;</code> , LPS 数组是 [0, 0, 1, 0, 1, 2, 3, 0, 0, 1, 2, 3, 4, 5, 6, 7, 4, 0]。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><span class="hljs-symbol">LPS</span>[i] 含义：字符串 pattern[:i+<span class="hljs-number">1</span>] 的 <span class="hljs-symbol">LPS</span> 的长度<br><br><span class="hljs-string">&quot;a&quot;</span>: 公共严格前后缀为<span class="hljs-string">&quot;&quot;</span> 或者说 无公共严格前后缀, <span class="hljs-symbol">LPS</span>[<span class="hljs-number">0</span>] 永远等于<span class="hljs-number">0</span><br><br><span class="hljs-string">&quot;ab&quot;</span>: 无公共严格前后缀，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br><br><span class="hljs-string">&quot;aba&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;a&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span><br><br><span class="hljs-string">&quot;abaz&quot;</span>: 无公共严格前后缀，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span><br><br><span class="hljs-string">&quot;abaza&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;a&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">4</span>] = <span class="hljs-number">1</span><br><br><span class="hljs-string">&quot;abazab&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;ab&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">5</span>] = <span class="hljs-number">2</span><br><br><span class="hljs-string">&quot;abazaba&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;aba&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">6</span>] = <span class="hljs-number">3</span><br><br><span class="hljs-string">&quot;abazabax&quot;</span>: 无公共严格前后缀，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">7</span>] = <span class="hljs-number">0</span><br><br><span class="hljs-string">&quot;abazabaxt&quot;</span>: 无公共严格前后缀，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">8</span>] = <span class="hljs-number">0</span><br><br><span class="hljs-string">&quot;abazabaxta&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;a&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">9</span>] = <span class="hljs-number">1</span><br><br><span class="hljs-string">&quot;abazabaxtab&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;ab&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">10</span>] = <span class="hljs-number">2</span><br><br><span class="hljs-string">&quot;abazabaxtaba&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;aba&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">11</span>] = <span class="hljs-number">3</span><br><br><span class="hljs-string">&quot;abazabaxtabaz&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;abaz&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">12</span>] = <span class="hljs-number">4</span><br><br><span class="hljs-string">&quot;abazabaxtabaza&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;abaza&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">13</span>] = <span class="hljs-number">5</span><br><br><span class="hljs-string">&quot;abazabaxtabazab&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;abazab&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">14</span>] = <span class="hljs-number">6</span><br><br><span class="hljs-string">&quot;abazabaxtabazaba&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;abazaba&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">15</span>] = <span class="hljs-number">7</span><br><br><span class="hljs-string">&quot;abazabaxtabazabaz&quot;</span>: 公共严格前后缀为 <span class="hljs-string">&quot;abazabaz&quot;</span>，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">16</span>] = <span class="hljs-number">4</span><br><br><span class="hljs-string">&quot;abazabaxtabazabazp&quot;</span>: 无公共严格前后缀，<span class="hljs-symbol">LPS</span>[<span class="hljs-number">17</span>] = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>如何使用代码来生成 LPS 数组呢？</strong></p><p>假设我们已经计算出了 <code>&quot;abazabaxtabazab&quot;</code> 的 LPS 为 <code>&quot;abazab&quot;</code> </p><img src="/2024/02/05/kmp/lps01.png" class=""><p>如何计算 <code>&quot;abazabaxtabazaba&quot;</code> 的 LPS 呢？</p><img src="/2024/02/05/kmp/lps10.png" class=""><p>显然 <span class="label label-primary">pattern[6] &#x3D;&#x3D; pattern[15]</span></p><img src="/2024/02/05/kmp/lps1.png" class=""><p> <code>&quot;abazabaxtabazaba&quot;</code> 的 LPS 为 <code>&quot;abazaba&quot;</code></p><img src="/2024/02/05/kmp/lps2.png" class=""><p>接下来计算 <code>&quot;abazabaxtabazabaz&quot;</code> 的 LPS</p><img src="/2024/02/05/kmp/lps3.png" class=""><p>此刻 <span class="label label-primary">pattern[7] !&#x3D; pattern[16]</span></p><img src="/2024/02/05/kmp/lps4.png" class=""><p>我们需要找到一个更短的前缀进行尝试</p><img src="/2024/02/05/kmp/lps5.png" class=""><p>此刻 <span class="label label-primary">pattern[4] &#x3D;&#x3D; pattern[16]</span></p><img src="/2024/02/05/kmp/lps6.png" class=""><p> <code>&quot;abazabaxtabazabaz&quot;</code> 的 LPS 为 <code>&quot;abaz&quot;</code></p><img src="/2024/02/05/kmp/lps7.png" class=""><p>最后计算 <code>&quot;abazabaxtabazabazp&quot;</code> 的 LPS</p><img src="/2024/02/05/kmp/lps8.png" class=""><p>发现没有更短前缀可以尝试(或者说这里在匹配 <code>&quot;&quot;</code> 前缀)，并且 <span class="label label-primary">pattern[0] !&#x3D; pattern[17]</span> ，所以 LPS &#x3D; 0</p><img src="/2024/02/05/kmp/lps9.png" class=""><p>当没有前缀可以匹配(或者说在匹配 <code>&quot;&quot;</code> 前缀)时的两种情况</p><ul><li>当前匹配字符与 <span class="label label-primary">pattern[0]</span> 相等，LPS &#x3D; 1</li><li>当前匹配字符与 <span class="label label-primary">pattern[0]</span> 不相等，LPS &#x3D; 0</li></ul><img src="/2024/02/05/kmp/lps_end.png" class=""><p>实现逻辑总结：</p><ol><li><p>我们在最开始初始化一个前缀长度变量 <code>prefix = 0</code> ，表示只有单个字符的字符串没有 LPS 。</p></li><li><p>然后从 <code>i = 1</code> 开始由短到长逐渐计算每个字符串的 LPS</p><p><strong>匹配成功时的增长：</strong> 如果字符匹配成功（<span class="label label-primary">pattern[i] &#x3D;&#x3D; pattern[prefix]</span>），则继续增加前缀的长度（<code>prefix += 1</code>）。</p><p><strong>匹配失败时的回退：</strong> 当发生匹配失败时（<span class="label label-primary">pattern[i] !&#x3D; pattern[prefix]</span>），通过回退的方式，找到一个更短的前缀进行尝试。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_lps_array</span>(<span class="hljs-params">pattern: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]:<br>    lps = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(pattern)<br><br>    <span class="hljs-comment"># 初始前缀长度为0</span><br>    prefix = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 从第二个字符开始遍历pattern</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(pattern)):<br>        <span class="hljs-comment"># 匹配失败时，回退前缀长度，条件 prefix &gt; 0 保证了可回退 </span><br>        <span class="hljs-keyword">while</span> prefix &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> pattern[i] != pattern[prefix]:<br>            prefix = lps[prefix - <span class="hljs-number">1</span>]<br><br>        <span class="hljs-comment"># 匹配成功，增加前缀长度</span><br>        <span class="hljs-keyword">if</span> pattern[i] == pattern[prefix]:<br>            prefix += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-comment"># 匹配失败时 lps[i] = 0</span><br>        lps[i] = prefix<br>    <br>    <span class="hljs-keyword">return</span> lps<br></code></pre></td></tr></table></figure><p><strong>时间复杂度分析</strong></p><p class="note note-info"> 初始时我觉得代码包括两层循环结构，所以时间复杂度是 O(m^2) ，其中 m 是 <span class="label label-primary">pattern</span> 的长度，但是网上都说是 O(m) 让我很难理解。</p><p>在每一轮 for 循环中，<code>prefix</code> 在匹配成功时增加1，而在匹配失败时可能经过多次回退。然而，总的回退次数受限于总的成功匹配次数，<code>prefix</code> 至多增加到 <code>m</code>，所以总的回退次数至多也是 <code>m</code>。因此，整体的时间复杂度为 <code>O(m)</code>。</p><p class="note note-info">可以这样想，我有一张初始余额为0 (prefix = 0)的银行卡，每次匹配成功，就在卡里存1块钱(prefix += 1)，每次匹配失败时，就花一次钱(prefix = lps[prefix - 1])，但是花钱的额度不能超过余额(同时是正整数元）。<br/><br/>在整个构建 lps[] 的过程中，我至多存 m 块钱，因此我至多消费 m 块钱，所以消费次数(匹配失败回退次数)一定不超过 m。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 回退虽然在两层循环中进行，但是整个过程至多回退m次</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(pattern)):<br>    <span class="hljs-keyword">while</span> prefix &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> pattern[i] != pattern[prefix]:<br>        prefix = lps[prefix - <span class="hljs-number">1</span>]<br>    <br>    <span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><p>打破了我对嵌套的两层循环，一定是平方时间复杂度的认知。下面的这个例子，时间复杂度是 <code>O(nlogn)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 外层循环n次，内层循环log(n)次</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j *= <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-comment">// 做一些操作</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-搜索部分"><a href="#3-4-搜索部分" class="headerlink" title="3.4 搜索部分"></a><span class="label label-warning">3.4 搜索部分</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">kmp_search</span>(<span class="hljs-params">text: <span class="hljs-built_in">str</span>, pattern: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    lps = compute_lps_array(pattern)<br>    text_index = pattern_index = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">while</span> text_index &lt; <span class="hljs-built_in">len</span>(text):<br>        <span class="hljs-comment"># 如果当前字符匹配，则继续比较下一个字符</span><br>        <span class="hljs-keyword">if</span> text[text_index] == pattern[pattern_index]:<br>            text_index += <span class="hljs-number">1</span><br>            pattern_index += <span class="hljs-number">1</span><br>            <br>            <span class="hljs-comment"># 如果pattern的所有字符都匹配，则返回匹配的起始索引</span><br>            <span class="hljs-keyword">if</span> pattern_index == <span class="hljs-built_in">len</span>(pattern):<br>                <span class="hljs-keyword">return</span> text_index - <span class="hljs-built_in">len</span>(pattern)<br>        <span class="hljs-comment"># 如果当前字符不匹配，并且pattern的索引不是0，则回退到上一个匹配字符的位置</span><br>        <span class="hljs-keyword">elif</span> pattern_index != <span class="hljs-number">0</span>:<br>            pattern_index = lps[pattern_index - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果当前字符不匹配，并且pattern的索引已经是0，继续检查text的下一个字符</span><br>            text_index += <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>搜索部分的时间复杂度为 <code>O(n)</code>，其中 <code>n</code> 为 <span class="label label-danger">text</span> 的长度。</p><p class="note note-info">分析同上，<span class="label label-primary">pattern_index</span> 在匹配成功时增加1，在匹配失败时回退。然而，总的回退次数受限于总的成功匹配次数，<span class="label label-primary">pattern_index</span> 至多增加 n 次，所以总的回退次数至多也是 n。因此，整体的时间复杂度为 O(n)。</p><p>所以 KMP 算法的总体时间复杂度为 <code>O(m + n)</code>。</p><h2 id="4-效率对比"><a href="#4-效率对比" class="headerlink" title="4 效率对比"></a><span class="label label-danger">4 效率对比</span></h2><p>起因是我想知道自己实现的 KMP 算法与 Python 自带的 str.find() 方法有多大的差距。</p><p>测试代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">brute_force_search</span>(<span class="hljs-params">text, pattern</span>):<br>    text_len = <span class="hljs-built_in">len</span>(text)<br>    pattern_len = <span class="hljs-built_in">len</span>(pattern)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(text_len - pattern_len + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">match</span> = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(pattern_len):<br>            <span class="hljs-keyword">if</span> text[i + j] != pattern[j]:<br>                <span class="hljs-keyword">match</span> = <span class="hljs-literal">False</span><br>                <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">match</span>:<br>            <span class="hljs-keyword">return</span> i<br><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_lps_array</span>(<span class="hljs-params">pattern: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>]:<br>    lps = [<span class="hljs-number">0</span>] * <span class="hljs-built_in">len</span>(pattern)<br><br>    <span class="hljs-comment"># 初始前缀长度为0</span><br>    prefix = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 从第二个字符开始遍历pattern</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(pattern)):<br>        <span class="hljs-comment"># 匹配失败时，回退前缀长度，条件 prefix &gt; 0 保证了可回退 </span><br>        <span class="hljs-keyword">while</span> prefix &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> pattern[i] != pattern[prefix]:<br>            prefix = lps[prefix - <span class="hljs-number">1</span>]<br><br>        <span class="hljs-comment"># 匹配成功，增加前缀长度（包括了 prefix = 0 且 匹配成功的情况）</span><br>        <span class="hljs-keyword">if</span> pattern[i] == pattern[prefix]:<br>            prefix += <span class="hljs-number">1</span><br>        <br>        <span class="hljs-comment"># 匹配失败时 lps[i] = 0</span><br>        lps[i] = prefix<br>    <br>    <span class="hljs-keyword">return</span> lps<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">kmp_search</span>(<span class="hljs-params">text: <span class="hljs-built_in">str</span>, pattern: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>    lps = compute_lps_array(pattern)<br>    text_index = pattern_index = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">while</span> text_index &lt; <span class="hljs-built_in">len</span>(text):<br>        <span class="hljs-comment"># 如果当前字符匹配，则继续比较下一个字符</span><br>        <span class="hljs-keyword">if</span> text[text_index] == pattern[pattern_index]:<br>            text_index += <span class="hljs-number">1</span><br>            pattern_index += <span class="hljs-number">1</span><br>            <br>            <span class="hljs-comment"># 如果pattern的所有字符都匹配，则返回匹配的起始索引</span><br>            <span class="hljs-keyword">if</span> pattern_index == <span class="hljs-built_in">len</span>(pattern):<br>                <span class="hljs-keyword">return</span> text_index - <span class="hljs-built_in">len</span>(pattern)<br>        <span class="hljs-comment"># 如果当前字符不匹配，并且pattern的索引不是0，则回退到上一个匹配字符的位置</span><br>        <span class="hljs-keyword">elif</span> pattern_index != <span class="hljs-number">0</span>:<br>            pattern_index = lps[pattern_index - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果当前字符不匹配，并且pattern的索引已经是0，继续检查text的下一个字符</span><br>            text_index += <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br><br><span class="hljs-comment"># 创建文本和模式</span><br>text = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">1000000</span> + <span class="hljs-string">&#x27;b&#x27;</span><br>pattern = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">100</span> + <span class="hljs-string">&#x27;b&#x27;</span><br><br><span class="hljs-comment"># 测试暴力搜索算法</span><br>start = time.time()<br>res = brute_force_search(text, pattern)<br>end = time.time()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Brute Force Search:&#x27;</span>, (end - start) * <span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;ms, res =&#x27;</span>, res)<br><br><span class="hljs-comment"># 测试KMP算法</span><br>start = time.time()<br>res = kmp_search(text, pattern)<br>end = time.time()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;KMP Search:&#x27;</span>, (end - start) * <span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;ms, res =&#x27;</span>, res)<br><br><span class="hljs-comment"># Python find()</span><br>start = time.time()<br>res = text.find(pattern)<br>end = time.time()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Python find:&#x27;</span>, (end - start) * <span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;ms, res =&#x27;</span>, res)<br><br><span class="hljs-comment"># output</span><br><span class="hljs-comment"># Brute Force Search: 10057.930946350098 ms, res = 999900</span><br><span class="hljs-comment"># KMP Search: 449.2683410644531 ms, res = 999900</span><br><span class="hljs-comment"># Python find: 1.7478466033935547 ms, res = 999900</span><br></code></pre></td></tr></table></figure><p>最开始很震惊，为什么 Python str.find() 方法运行效率比我的 KMP 快这么多？</p><p class="note note-info">Python 自带的 find 方法是用 C 语言实现的，在底层经过高度优化，因此在大多数情况下会比纯 Python 代码更快。<br/><br/>而 KMP 算法虽然在某些情况下比朴素的字符串匹配算法更高效，但是它的实现依然是纯 Python 代码。尽管 KMP 算法的时间复杂度为 O(n + m)，其中 n 为文本长度，m 为模式串长度，但是在实际情况下，算法中涉及了大量的数组操作和条件判断，这些操作在 Python 中相比 C 语言而言速度会慢一些。因此，对于较大规模的数据，Python  自带的 find 方法通常会更快，因为它是直接调用底层 C 代码执行查找操作。<br/><br/>总的来说，Python 的内置方法通常会经过高度优化，运行速度更快，但在一些特定情况下，使用自定义的算法可能会更适合。</p><p>下面使用 C 来实现 KMP 算法看一下运行效率。</p><h2 id="5-C语言-KMP"><a href="#5-C语言-KMP" class="headerlink" title="5 C语言 KMP"></a><span class="label label-secondary">5 C语言 KMP</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">kmp_search</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* text, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* pattern)</span> &#123;<br>    <span class="hljs-type">int</span> tlen = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (text[tlen] != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        tlen++;<br>    &#125;<br><br>    <span class="hljs-type">int</span> plen = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (pattern[plen] != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        plen++;<br>    &#125;<br><br>    <span class="hljs-type">int</span>* lps = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(plen * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (lps == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 内存分配失败</span><br>    &#125;<br><br>    <span class="hljs-comment">// 构建 lps 数组</span><br>    <span class="hljs-type">int</span> prefix = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; plen; i++) &#123;<br>        <span class="hljs-keyword">while</span> (prefix &gt; <span class="hljs-number">0</span> &amp;&amp; pattern[i] != pattern[prefix]) &#123;<br>            prefix = lps[prefix - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (pattern[i] == pattern[prefix]) &#123;<br>            prefix++;<br>        &#125;<br><br>        lps[i] = prefix;<br>    &#125;<br><br>    <span class="hljs-comment">// 匹配过程</span><br>    <span class="hljs-type">int</span> pi = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ti = <span class="hljs-number">0</span>; ti &lt; tlen; ti++) &#123;<br>        <span class="hljs-keyword">while</span> (pi &gt; <span class="hljs-number">0</span> &amp;&amp; text[ti] != pattern[pi]) &#123;<br>            pi = lps[pi - <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (text[ti] == pattern[pi]) &#123;<br>            <span class="hljs-keyword">if</span> (pi == plen - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">free</span>(lps);<br>                <span class="hljs-keyword">return</span> ti - plen + <span class="hljs-number">1</span>;<br>            &#125;<br>            pi++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">free</span>(lps);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义一个函数，用于生成由n个c字符组成的字符串</span><br><span class="hljs-type">char</span> *<span class="hljs-title function_">repeat_char</span><span class="hljs-params">(<span class="hljs-type">char</span> c, <span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-comment">// 分配n+1个字节的内存空间，用于存储字符串和结束符&#x27;\0&#x27;</span><br>    <span class="hljs-type">char</span> *s = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 判断内存分配是否成功</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;内存分配失败\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 使用memset函数，将s的前n个字节都填充为c字符</span><br>    <span class="hljs-built_in">memset</span>(s, c, n);<br>    <span class="hljs-comment">// 在最后一个字节添加结束符&#x27;\0&#x27;</span><br>    s[n] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-comment">// 返回生成的字符串</span><br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span>* text = repeat_char(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1000001</span>);<br>    text[<span class="hljs-number">1000000</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>    <span class="hljs-type">char</span>* pattern = repeat_char(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">101</span>);<br>    pattern[<span class="hljs-number">100</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br><br>    <span class="hljs-type">clock_t</span> start_time = clock();<br>    <span class="hljs-type">int</span> result = kmp_search(text, pattern);<br>    <span class="hljs-type">clock_t</span> end_time = clock();<br>    <span class="hljs-type">double</span> execution_time = ((<span class="hljs-type">double</span>)(end_time - start_time)) / CLOCKS_PER_SEC * <span class="hljs-number">1000.0</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Execution Time: %f ms\n&quot;</span>, execution_time);<br><br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Pattern found at index %d\n&quot;</span>, result);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Pattern not found in the text\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">// output</span><br><span class="hljs-comment">// Execution Time: 8.270000 ms</span><br><span class="hljs-comment">// Pattern found at index 999900</span><br></code></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">text</span> = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">1000000</span> + <span class="hljs-string">&#x27;b&#x27;</span><br><span class="hljs-attr">pattern</span> = <span class="hljs-string">&#x27;a&#x27;</span> * <span class="hljs-number">100</span> + <span class="hljs-string">&#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><p>用时对比：</p><table><thead><tr><th>Algorithm</th><th>Time (ms)</th></tr></thead><tbody><tr><td>Brute Force Search (Python)</td><td>10057.931</td></tr><tr><td>KMP Search (Python)</td><td>449.268</td></tr><tr><td>KMP Search (C)</td><td>8.270</td></tr><tr><td>Python find</td><td>1.748</td></tr></tbody></table><p>可以看出 Python 和 C 的执行效率存在巨大差距。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
      <category>String Matching</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>Python</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解CAS</title>
    <link href="/2022/08/19/cas/"/>
    <url>/2022/08/19/cas/</url>
    
    <content type="html"><![CDATA[<h3 id="Java层面探究"><a href="#Java层面探究" class="headerlink" title="Java层面探究"></a><span class="label label-primary">Java层面探究</span></h3><p>Java中的原子类<code>Atomic</code>底层的实现原理是CAS，本文就让我们一起来深入探究CAS。<br>下面是<code>AtomicInteger</code>的测试代码 ，执行完毕后会发现原子类实例<code>ai</code>最终是精确的10000，而普通变量<code>bi</code>的值是一个小于10000的不固定的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hw.review2022.concurrent;<br> <br><span class="hljs-keyword">import</span> org.junit.Test;<br> <br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCAS</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 被多个线程访问的变量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ai</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">bi</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对ai和bi执行1000次自增</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-comment">//任务id</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br> <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Task</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>            <span class="hljs-built_in">this</span>.id = i;<br>        &#125;<br> <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>               <span class="hljs-keyword">try</span>&#123;<br>                   <span class="hljs-keyword">if</span>(i % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>) &#123;<br>                       System.out.println(<span class="hljs-string">&quot;Thread name : &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;, Task id : &quot;</span> + id + <span class="hljs-string">&quot;, loop : &quot;</span> + i);<br>                   &#125;<br>                   Thread.sleep(<span class="hljs-number">2</span>);<br>                   ai.addAndGet(<span class="hljs-number">1</span>);<br>                   bi++;<br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                   e.printStackTrace();<br>               &#125;<br>           &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 创建含有3个线程的线程池</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 在线程池中执行10个任务</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(i));<br>        &#125;<br> <br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 等待线程池中的任务执行完毕后才去打印ai和bi的值</span><br><span class="hljs-comment">         */</span><br>        executor.shutdown();<br>        executor.awaitTermination(<span class="hljs-number">60</span>, TimeUnit.SECONDS);<br>        System.out.println(<span class="hljs-string">&quot;ai is right : &quot;</span> + ai);<br>        System.out.println(<span class="hljs-string">&quot;bi is wrong : &quot;</span> + bi);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码的核心是 <code>AtomicInteger.addAndGet</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> valueOffset;<br>    <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Atomically adds the given value to the current value.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> delta the value to add</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the updated value</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addAndGet</span><span class="hljs-params">(<span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-built_in">this</span>, valueOffset, delta) + delta;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们看一下<code>AtomicInteger</code>类实例对象的内存布局</p><img src="/2022/08/19/cas/layout.png" class=""><p><code>this</code>指向了对象的起始地址，通过<code>this + valueOffset(=12)</code>我们就可以获得<code>value</code>字段的内存地址（即C&#x2F;C++中的指向<code>value</code>的指针），进而读写该<code>value</code>值。</p><p>然后我们接着看<code>Unsafe.getAndAddInt</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//                             原子实例ai  valueOffset  delta(增量)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">int</span> var4)</span> &#123;<br>    <span class="hljs-type">int</span> var5;<br>    <span class="hljs-keyword">do</span> &#123;<br>        var5 = <span class="hljs-built_in">this</span>.getIntVolatile(var1, var2); <span class="hljs-comment">// var5: oldValue</span><br>    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4)); <span class="hljs-comment">// var5 + var4: updateValue</span><br> <br>    <span class="hljs-keyword">return</span> var5;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>var5</code>这个变量是通过<code>ai</code>的起始地址 + <code>valueOffset</code>偏移值获取到<code>value</code>的内存地址，进而获取到的<code>value</code>的值，我们把这个值称为<span class="label label-primary">oldValue</span></p><p><code>var5+var4</code>就是我们期望更新的值，我们把它叫做<span class="label label-info">updateValue</span></p><p>接下来发现<code>Unsafe.compareAndSwapInt</code>是一个 native 方法(就是在Java虚拟机中用 C&#x2F;C++ 实现的方法)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapInt</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">int</span> var4, <span class="hljs-type">int</span> var5)</span>;<br></code></pre></td></tr></table></figure><h3 id="C-x2F-C-层面探究"><a href="#C-x2F-C-层面探究" class="headerlink" title="C&#x2F;C++层面探究"></a><span class="label label-success">C&#x2F;C++层面探究</span></h3><p>现在Java语言层面我们已经分析完了，完全看不到CAS具体是怎么实现的，接下来我们继续去探究JDK源码<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Github OpenJDK8源码](https://github.com/AdoptOpenJDK/openjdk-jdk8u)">[1]</span></a></sup></p><p><code>Unsafe.compareAndSwapInt</code>的源码所在目录为<code>hotspot/src/share/vm/prims/unsafe.cpp</code></p><p>这个方法的前两个参数不用去了解（JNI是Java调用C的方式），后四个参数和<code>Unsafe.compareAndSwapInt</code>方法的一一对应。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">UNSAFE_ENTRY</span>(jboolean, <span class="hljs-built_in">Unsafe_CompareAndSwapInt</span>(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))<br>  <span class="hljs-built_in">UnsafeWrapper</span>(<span class="hljs-string">&quot;Unsafe_CompareAndSwapInt&quot;</span>);<br>  oop p = JNIHandles::<span class="hljs-built_in">resolve</span>(obj);<br>  jint* addr = (jint *) <span class="hljs-built_in">index_oop_from_field_offset_long</span>(p, offset);<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * x代表了期望更新的值updateValue</span><br><span class="hljs-comment">   * addr代表了value这个字段的内存地址</span><br><span class="hljs-comment">   * e代表了oldValue</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">return</span> (jint)(Atomic::<span class="hljs-built_in">cmpxchg</span>(x, addr, e)) == e;<br>UNSAFE_END<br></code></pre></td></tr></table></figure><p>继续往下分析来到了最核心的部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">inline</span> jint     <span class="hljs-title function_">Atomic::cmpxchg</span>    <span class="hljs-params">(jint     exchange_value, <span class="hljs-keyword">volatile</span> jint*     dest, jint     compare_value)</span> &#123;<br>  <span class="hljs-type">int</span> mp = os::is_MP(); <span class="hljs-comment">// MP means multiprocessor，多处理器系统需要给cmpxchg指令加上lock前缀</span><br>  __asm__ <span class="hljs-title function_">volatile</span> <span class="hljs-params">(LOCK_IF_MP(%<span class="hljs-number">4</span>) <span class="hljs-string">&quot;cmpxchgl %1,(%3)&quot;</span></span><br><span class="hljs-params">                    : <span class="hljs-string">&quot;=a&quot;</span> (exchange_value)</span><br><span class="hljs-params">                    : <span class="hljs-string">&quot;r&quot;</span> (exchange_value), <span class="hljs-string">&quot;a&quot;</span> (compare_value), <span class="hljs-string">&quot;r&quot;</span> (dest), <span class="hljs-string">&quot;r&quot;</span> (mp)</span><br><span class="hljs-params">                    : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>)</span>;<br>  <span class="hljs-keyword">return</span> exchange_value;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>cmpxchgl</code>是一个汇编指令（最后一个字符<code>l</code>代表了<code>cmpxchg</code>指令的参数类型为<code>jint</code>，对于<code>jlong</code>类型最后一个字符是<code>q</code>，不同操作系统可能会不同），所以我们需要去理解<code>cmpxchg</code>这条汇编指令。</p><h3 id="汇编层面探究"><a href="#汇编层面探究" class="headerlink" title="汇编层面探究"></a><span class="label label-danger">汇编层面探究</span></h3><p>下面给出我在C中实现的CAS来帮助大家理解CAS和<code>cmpxchg</code>指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pthread.h&quot;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> oldValue, <span class="hljs-type">int</span>* addr, <span class="hljs-type">int</span> updateValue)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">atomic_add</span><span class="hljs-params">(<span class="hljs-type">int</span>* addr, <span class="hljs-type">int</span> delta)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">task</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">atomic_task</span><span class="hljs-params">()</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 被多个线程访问的共享变量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-type">atomic_count</span> = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br> <br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试代码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">pthread_t</span> tid, tid2, tid3, tid4, tid5, tid6;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建了6个子线程，tid为子线程id，task和atomic_task是子线程的任务函数</span><br><span class="hljs-comment">     */</span><br>    pthread_create(&amp;tid, <span class="hljs-literal">NULL</span>, (<span class="hljs-type">void</span> *) task, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid2, <span class="hljs-literal">NULL</span>, (<span class="hljs-type">void</span> *) task, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid3, <span class="hljs-literal">NULL</span>, (<span class="hljs-type">void</span> *) task, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid4, <span class="hljs-literal">NULL</span>, (<span class="hljs-type">void</span> *) <span class="hljs-type">atomic_task</span>, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid5, <span class="hljs-literal">NULL</span>, (<span class="hljs-type">void</span> *) <span class="hljs-type">atomic_task</span>, <span class="hljs-literal">NULL</span>);<br>    pthread_create(&amp;tid6, <span class="hljs-literal">NULL</span>, (<span class="hljs-type">void</span> *) <span class="hljs-type">atomic_task</span>, <span class="hljs-literal">NULL</span>);<br> <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 主线程等待6个子线程执行完才会往下执行printf</span><br><span class="hljs-comment">     */</span><br>    pthread_join(tid, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid2, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid3, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid4, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid5, <span class="hljs-literal">NULL</span>);<br>    pthread_join(tid6, <span class="hljs-literal">NULL</span>);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;count is %d\n&quot;</span>, count); <span class="hljs-comment">//预期最后的结果小于900000</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;atomic_count is %d\n&quot;</span>, <span class="hljs-type">atomic_count</span>); <span class="hljs-comment">//预期最后的结果精确等于900000</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>   <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param oldValue 最开始获取到的value值</span><br><span class="hljs-comment"> * @param addr 多线程访问的变量的地址</span><br><span class="hljs-comment"> * @param updateValue 期望更新的新值</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> oldValue, <span class="hljs-type">int</span>* addr, <span class="hljs-type">int</span> updateValue)</span> &#123;<br>    <span class="hljs-type">int</span> resValue;<br>    __asm__ __volatile__ (<span class="hljs-string">&quot;lock\n\t&quot;</span><br>                          <span class="hljs-string">&quot;cmpxchgl %2, (%3)&quot;</span><br>                          : <span class="hljs-string">&quot;=a&quot;</span>(resValue)<br>                          : <span class="hljs-string">&quot;a&quot;</span>(oldValue), <span class="hljs-string">&quot;r&quot;</span>(updateValue), <span class="hljs-string">&quot;r&quot;</span>(addr)<br>                          : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>);<br>    <span class="hljs-keyword">return</span> resValue;<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param addr 多线程访问变量的地址</span><br><span class="hljs-comment"> * @param delta 这个变量想要增加的值</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">atomic_add</span><span class="hljs-params">(<span class="hljs-type">int</span>* addr, <span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-type">int</span> oldValue;<br>    <span class="hljs-keyword">do</span> &#123;<br>        oldValue = *addr;<br>    &#125; <span class="hljs-keyword">while</span> ( cmp(oldValue, addr, oldValue + delta) != oldValue );<br>&#125;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">atomic_task</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">300000</span>; i++) &#123;<br>        <span class="hljs-type">atomic_add</span>(&amp;<span class="hljs-type">atomic_count</span>, <span class="hljs-number">1</span>);<br>        usleep(<span class="hljs-number">60</span>);<br>    &#125;<br>&#125;<br> <br><span class="hljs-type">void</span> <span class="hljs-title function_">task</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">300000</span>; i++) &#123;<br>        count += <span class="hljs-number">1</span>;<br>        usleep(<span class="hljs-number">60</span>); <span class="hljs-comment">//0.06ms</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重点讲解一下<code>cmp</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> oldValue, <span class="hljs-type">int</span>* addr, <span class="hljs-type">int</span> updateValue)</span> &#123;<br>    <span class="hljs-type">int</span> resValue;<br>    __asm__ __volatile__ (<span class="hljs-string">&quot;lock\n\t&quot;</span>   <span class="hljs-comment">//保证原子性</span><br>                          <span class="hljs-string">&quot;cmpxchgl %2, (%3)&quot;</span> <span class="hljs-comment">//核心指令</span><br>                          : <span class="hljs-string">&quot;=a&quot;</span>(resValue) <span class="hljs-comment">//输出列表</span><br>                          : <span class="hljs-string">&quot;a&quot;</span>(oldValue), <span class="hljs-string">&quot;r&quot;</span>(updateValue), <span class="hljs-string">&quot;r&quot;</span>(addr) <span class="hljs-comment">//输入列表</span><br>                          : <span class="hljs-string">&quot;cc&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>); <span class="hljs-comment">//表明这条内联汇编会更改内存值和flag寄存器</span><br>    <span class="hljs-keyword">return</span> resValue;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实也就是我自己实现的JDK中的<code>Atomic::cmpxchg</code>函数，只不过更容易看懂一些。</p><p><span class="label label-primary">oldValue</span>就是我们先前获取到的<code>value</code>值，<code>addr</code>就是<code>value</code>字段的内存地址，在<code>cmpxchg</code>指令中会用到这个地址，<span class="label label-info">updateValue</span>就是我们期望更新的<code>value</code>值(<span class="label label-primary">oldValue</span>+增量<code>delta</code>)</p><p>以下关于内联汇编的知识大家可以去参考GCC-Inline-Assembly-HOWTO<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[GCC-Inline-Assembly-HOWTO](http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html)">[2]</span></a></sup></p><p>输入列表中：</p><p><code>&quot;a&quot;(oldValue)</code>：a代表EAX寄存器，意思是将变量<span class="label label-primary">oldValue</span>的值输入到EAX寄存器</p><p><code>&quot;r&quot;(updateValue) &quot;r&quot;(addr)</code>：意思是将变量<span class="label label-info">updateValue</span>和地址<code>addr</code>也放到寄存器中，r(register)代表一组寄存器，也就是从这一组寄存器中随便选一个存<span class="label label-info">updateValue</span>，随便选一个存<code>addr</code></p><p>输出列表中：</p><p><code>&quot;=a&quot;(resValue)</code>：表示内联汇编执行完后，将EAX寄存器的值存到<code>resValue</code>这个变量中。</p><p>我们在输出列表和输入列表中声明了许多变量，这些变量从<code>%0</code>开始依次往下标号，所以<code>%0</code>表示<code>resValue</code>，<code>%1</code>代表了<span class="label label-primary">oldValue</span>，<code>%2</code>代表了<span class="label label-info">updateValue</span>，<code>%3</code>代表了<code>addr</code>。</p><p>现在我们结合的<code>cmpxchg</code>指令的功能，来理解一下这段汇编到底在做什么。汇编语言有Intel和AT&amp;T两种语法，一般我们用的都是AT&amp;T这种，下面的讲解也是基于该语法的:</p><p class="note note-info">cmpxchg 指令有两个操作数，同时还使用了EAX 寄存器。首先，它将第二个操作数和EAX寄存器相比较，如果相同则把第一个操作数赋值给第二个操作数，否则将第一个操作数赋值给EAX 寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmpxchgl %2, (%3) <br></code></pre></td></tr></table></figure><p><code>%2</code>是第一个操作数，即<span class="label label-info">updateValue</span>，也就是无冲突的时候我们期望更新的值</p><p><code>(%3)</code>是第二个操作数，即<code>(addr)</code>，<code>()</code>表示取值操作(相当于C语言中的<code>*</code>)，因为<code>addr</code>是<code>value</code>变量的地址，所以该操作数是在取此刻<code>value</code>的值<code>curValue</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *a = <span class="hljs-number">5</span>; <span class="hljs-comment">//代表了a是一个指针，指向一个int变量，即a是该int变量的地址，*a表示取该int变量的值5</span><br></code></pre></td></tr></table></figure><p>首先将<span class="label label-primary">oldValue</span>存储到EAX寄存器中，然后用第二个操作数<code>curValue</code>和<span class="label label-primary">oldValue</span>行比较，如果相等，则说明从得到<span class="label label-primary">oldValue</span>到现在执行<code>cmpxchg</code>这条指令这段时间内，<code>value</code>没有被其他线程改写（抛开ABA问题不谈），没有发生冲突，所以我们就可以直接把我们希望更新的新值<span class="label label-info">updateValue</span>写入到<code>value</code>中，那我们再来看看<code>cmpxchg</code>这条指令干了啥，如果相同则把第一个操作数赋值给第二个操作数，也就是将<span class="label label-info">updateValue</span>赋值给<code>value</code>对象（成功更新<code>value</code>的值）。现在这条指令就执行完毕了，EAX寄存器中存储的还是<span class="label label-primary">oldValue</span>，所以最终<code>cmp</code>函数返回的也就是<span class="label label-primary">oldValue</span></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">atomic_add</span><span class="hljs-params">(<span class="hljs-type">int</span>* addr, <span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-type">int</span> oldValue;<br>    <span class="hljs-keyword">do</span> &#123;<br>        oldValue = *addr;<br>    &#125; <span class="hljs-keyword">while</span> ( cmp(oldValue, addr, oldValue + delta) != oldValue );<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数也就可以返回了，对应的就是Java中的<code>Unsafe.getAndAddInt</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-type">long</span> var2, <span class="hljs-type">int</span> var4)</span> &#123;<br>    <span class="hljs-type">int</span> var5;<br>    <span class="hljs-keyword">do</span> &#123;<br>        var5 = <span class="hljs-built_in">this</span>.getIntVolatile(var1, var2);<br>    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<br> <br>    <span class="hljs-keyword">return</span> var5;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果EAX中保存的<span class="label label-primary">oldValue</span>和我们执行<code>cmpxchg</code>指令时获取的<code>curValue</code>不同，说明<code>value</code>的值被其他线程改写了，那此刻将第一个操作数<span class="label label-info">updateValue</span>赋值给 EAX 寄存器（我们并没有更新<code>value</code>的值），所以<code>cmp</code>函数返回的值为<span class="label label-info">updateValue</span>。<code>atomic_add</code>函数中<code>cmp</code>返回的<span class="label label-info">updateValue</span>和<span class="label label-primary">oldValue</span>不同，所以要重新执行<code>do while</code>循环去自旋，直到没有冲突发生。</p><h3 id="动画展示与总结"><a href="#动画展示与总结" class="headerlink" title="动画展示与总结"></a><span class="label label-info">动画展示与总结</span></h3><p>该动画使用Python <code>manim</code>库<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Github 3b1b/manim](https://github.com/3b1b/manim)">[3]</span></a></sup>制作，<a href="https://github.com/hwollin/animation/blob/main/os/thread/concurrent/cas_animation.py">动画源码</a></p><video width="100%" controls>  <source src="cas.mp4" type="video/mp4"></video><p>最后我们再用高级语言解释一下<code>cmpxchg</code>这条汇编指令的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 被多个线程访问的value对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> value;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注意下面的逻辑是一条汇编指令完成的</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param addr value对象的内存地址</span><br><span class="hljs-comment"> * @param oldValue 执行cmpxchg指令前当前线程获取到的value对象的值</span><br><span class="hljs-comment"> * @param updateValue 期望更新的值</span><br><span class="hljs-comment"> * @return</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">cmpxchg</span><span class="hljs-params">(<span class="hljs-type">int</span>* addr, <span class="hljs-type">int</span> oldValue, <span class="hljs-type">int</span> updateValue)</span><br>&#123;<br>    <span class="hljs-type">int</span> curValue = *addr; <span class="hljs-comment">//获取最新的value的值</span><br>    <span class="hljs-keyword">if</span> (curValue == oldValue) &#123; <span class="hljs-comment">//无冲突则更新value值为updateValue并返回oldValue</span><br>        *addr == updateValue;<br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//发生冲突，直接返回updateValue，value对象的值没有更新哦</span><br>        <span class="hljs-keyword">return</span> updateValue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a><span class="label label-warning">引用</span></h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://github.com/AdoptOpenJDK/openjdk-jdk8u">Github OpenJDK8源码</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">GCC-Inline-Assembly-HOWTO</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://github.com/3b1b/manim">Github 3b1b&#x2F;manim</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Concurrency Programming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>C/C++</tag>
      
      <tag>Assembly</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
